â‰ =<!-- This file was written by Cluade 4.6 LLM via the prompt of Josh Kirby -->
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Fourier Explorer v6 â€” TECHIN 513A</title>
        <style>
            @import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Outfit:wght@400;500;600;700&family=Newsreader:ital,wght@0,400;0,500;0,600;1,400&display=swap');
            :root {
                --bg: #06060b;
                --s: rgba(255, 255, 255, 0.025);
                --sh: rgba(255, 255, 255, 0.05);
                --bd: rgba(255, 255, 255, 0.07);
                --ba: #7c3aed;
                --ac: #a78bfa;
                --ad: rgba(124, 58, 237, 0.12);
                --gn: #34d399;
                --gd: rgba(52, 211, 153, 0.12);
                --am: #fbbf24;
                --amd: rgba(251, 191, 36, 0.1);
                --rs: #fb7185;
                --rsd: rgba(251, 113, 133, 0.1);
                --cy: #22d3ee;
                --cyd: rgba(34, 211, 238, 0.1);
                --tx: #d4d4e0;
                --td: rgba(255, 255, 255, 0.4);
                --tm: rgba(255, 255, 255, 0.22);
                --mo: 'DM Mono', 'SF Mono', monospace;
                --sn: 'Outfit', -apple-system, sans-serif;
                --se: 'Newsreader', Georgia, serif;
                --extract-color: #22d3ee;
                --extract-dim: rgba(34, 211, 238, 0.15);
            }
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }
            ::selection {
                background: #7c3aed;
                color: #fff;
            }
            body {
                background: var(--bg);
                color: var(--tx);
                font-family: var(--sn);
                min-height: 100vh;
                padding: 24px 16px 270px;
            }
            .ctn {
                max-width: 900px;
                margin: 0 auto;
            }
            h1 {
                font-size: 24px;
                font-weight: 700;
                letter-spacing: -0.03em;
                background: linear-gradient(135deg, #c4b5fd, #60a5fa, #22d3ee);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 3px;
            }
            .sub {
                font-family: var(--mo);
                font-size: 11px;
                color: var(--td);
                margin-bottom: 22px;
            }
            .sec {
                margin-bottom: 18px;
            }
            .sl {
                font-family: var(--mo);
                font-size: 10px;
                font-weight: 600;
                color: var(--td);
                text-transform: uppercase;
                letter-spacing: 0.1em;
                margin-bottom: 7px;
            }
            .uz {
                border: 2px dashed var(--bd);
                border-radius: 10px;
                padding: 20px;
                text-align: center;
                cursor: pointer;
                transition: all 0.2s;
                background: var(--s);
            }
            .uz:hover,
            .uz.dg {
                border-color: var(--ba);
                background: var(--ad);
            }
            .uz input {
                display: none;
            }
            .ui {
                font-size: 22px;
                margin-bottom: 3px;
                opacity: 0.5;
            }
            .ut {
                font-family: var(--mo);
                font-size: 11px;
                color: var(--td);
            }
            .ut strong {
                color: var(--ac);
            }
            .uh {
                font-family: var(--mo);
                font-size: 9px;
                color: var(--tm);
                margin-top: 2px;
            }
            .fi {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 7px 12px;
                background: var(--ad);
                border: 1px solid rgba(124, 58, 237, 0.2);
                border-radius: 8px;
                font-family: var(--mo);
                font-size: 11px;
            }
            .fi .fn {
                color: var(--ac);
                font-weight: 500;
                flex: 1;
            }
            .fi .fm {
                color: var(--td);
            }
            .fi button {
                background: none;
                border: 1px solid rgba(255, 255, 255, 0.1);
                color: var(--td);
                border-radius: 5px;
                padding: 2px 7px;
                cursor: pointer;
                font-family: var(--mo);
                font-size: 9px;
            }
            .bg {
                display: flex;
                gap: 4px;
                flex-wrap: wrap;
            }
            .bt {
                font-family: var(--mo);
                font-size: 10px;
                padding: 5px 11px;
                border-radius: 5px;
                border: 1px solid var(--bd);
                background: var(--s);
                color: var(--td);
                cursor: pointer;
                transition: all 0.12s;
                white-space: nowrap;
            }
            .bt:hover {
                background: var(--sh);
                color: var(--tx);
            }
            .bt.ac {
                border-color: var(--ba);
                background: var(--ad);
                color: var(--ac);
            }
            [data-l] {
                cursor: pointer;
            }
            .tr {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 7px 12px;
                background: var(--s);
                border: 1px solid var(--bd);
                border-radius: 8px;
                margin-bottom: 8px;
                flex-wrap: wrap;
            }
            .tb {
                width: 30px;
                height: 30px;
                border-radius: 50%;
                border: 1px solid var(--bd);
                background: var(--s);
                color: var(--td);
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 13px;
                transition: all 0.15s;
                flex-shrink: 0;
            }
            .tb:hover {
                border-color: var(--ac);
                color: var(--ac);
                background: var(--ad);
            }
            .tb.pl {
                border-color: var(--gn);
                background: var(--gd);
                color: var(--gn);
            }
            .tb.ext {
                border-color: var(--cy);
                background: var(--cyd);
                color: var(--cy);
            }
            .tt {
                font-family: var(--mo);
                font-size: 11px;
                color: var(--ac);
                min-width: 85px;
                font-weight: 500;
            }
            .ts {
                flex: 1;
                min-width: 80px;
                -webkit-appearance: none;
                height: 3px;
                background: rgba(255, 255, 255, 0.08);
                border-radius: 2px;
                outline: none;
            }
            .ts::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 11px;
                height: 11px;
                border-radius: 50%;
                background: var(--ac);
                cursor: pointer;
                border: 2px solid var(--bg);
            }
            .at {
                display: flex;
                align-items: center;
                gap: 6px;
            }
            .at span {
                font-family: var(--mo);
                font-size: 9px;
                color: var(--td);
            }
            .tg {
                width: 36px;
                height: 18px;
                border-radius: 9px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid var(--bd);
                cursor: pointer;
                position: relative;
                transition: all 0.2s;
            }
            .tg.on {
                background: var(--ad);
                border-color: var(--ba);
            }
            .tg .kn {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: var(--td);
                position: absolute;
                top: 2px;
                left: 2px;
                transition: all 0.2s;
            }
            .tg.on .kn {
                left: 20px;
                background: var(--ac);
            }
            .tg.cy.on {
                background: var(--cyd);
                border-color: var(--cy);
            }
            .tg.cy.on .kn {
                background: var(--cy);
            }
            .sr {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 7px;
            }
            .srl {
                font-family: var(--mo);
                font-size: 9px;
                color: var(--td);
                min-width: 90px;
            }
            .srv {
                font-family: var(--mo);
                font-size: 10px;
                color: var(--ac);
                min-width: 50px;
                text-align: right;
                font-weight: 500;
            }
            input[type='range'] {
                flex: 1;
                -webkit-appearance: none;
                height: 3px;
                background: rgba(255, 255, 255, 0.08);
                border-radius: 2px;
                outline: none;
            }
            input[type='range']::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: var(--ac);
                cursor: pointer;
                border: 2px solid var(--bg);
            }
            .tabs {
                display: flex;
                gap: 2px;
                background: var(--s);
                border-radius: 8px;
                padding: 3px;
                margin-bottom: 12px;
            }
            .tab {
                flex: 1;
                padding: 8px 8px;
                border-radius: 6px;
                border: none;
                background: transparent;
                color: var(--td);
                font-family: var(--mo);
                font-size: 10px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.15s;
            }
            .tab.ac {
                background: var(--ad);
                color: var(--ac);
            }
            .cw {
                border-radius: 6px;
                overflow: hidden;
                border: 1px solid var(--bd);
                margin-bottom: 3px;
                position: relative;
            }
            .cw canvas {
                display: block;
                width: 100%;
            }
            .cc {
                font-family: var(--mo);
                font-size: 9px;
                color: var(--tm);
                margin-bottom: 10px;
            }
            .lb {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                font-family: var(--mo);
                font-size: 9px;
                color: var(--gn);
                padding: 2px 6px;
                background: var(--gd);
                border-radius: 3px;
                margin-left: 5px;
            }
            .ld {
                width: 5px;
                height: 5px;
                border-radius: 50%;
                background: var(--gn);
                animation: pu 1.2s infinite;
            }
            @keyframes pu {
                0%,
                100% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.3;
                }
            }
            .pg {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                margin-bottom: 14px;
            }
            .pc {
                background: var(--s);
                border: 1px solid var(--bd);
                border-radius: 6px;
                padding: 7px 10px;
                flex: 1 1 110px;
                min-width: 105px;
                cursor: pointer;
                transition: border-color 0.15s;
            }
            .pc:hover {
                border-color: var(--am);
            }
            .pc .pl {
                font-family: var(--mo);
                font-size: 9px;
                color: var(--td);
                margin-bottom: 1px;
            }
            .pc .pv {
                font-family: var(--mo);
                font-size: 15px;
                font-weight: 700;
                color: var(--ac);
            }
            .pc .pv .pu {
                font-size: 9px;
                color: var(--td);
                font-weight: 400;
                margin-left: 2px;
            }
            .pc .pd {
                font-family: var(--mo);
                font-size: 8px;
                color: var(--tm);
                margin-top: 1px;
            }
            .cg {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
                margin-bottom: 10px;
            }
            @media (max-width: 640px) {
                .cg {
                    grid-template-columns: 1fr;
                }
            }
            .cg label {
                display: block;
                font-family: var(--mo);
                font-size: 9px;
                color: var(--td);
                margin-bottom: 4px;
            }
            .aol {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-family: var(--mo);
                font-size: 11px;
                color: var(--tm);
                pointer-events: none;
                text-align: center;
            }
            .pr {
                margin-bottom: 10px;
            }
            .ft {
                text-align: center;
                font-family: var(--mo);
                font-size: 9px;
                color: var(--tm);
                padding-top: 14px;
            }

            /* Extract band indicator */
            .band-indicator {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 8px 14px;
                background: var(--cyd);
                border: 1px solid rgba(34, 211, 238, 0.2);
                border-radius: 8px;
                margin-bottom: 10px;
                font-family: var(--mo);
                font-size: 11px;
                color: var(--cy);
            }
            .band-indicator .bi-label {
                flex: 1;
            }

            /* FS */
            .fsn {
                font-family: var(--se);
                font-size: 12px;
                color: rgba(255, 255, 255, 0.5);
                line-height: 1.6;
                margin: 8px 0;
                padding: 8px 12px;
                border-left: 3px solid var(--am);
                background: var(--amd);
                border-radius: 0 5px 5px 0;
            }
            .fss {
                max-height: 350px;
                overflow-y: auto;
                border: 1px solid var(--bd);
                border-radius: 7px;
                background: rgba(0, 0, 0, 0.3);
                padding: 3px;
            }
            .fss::-webkit-scrollbar {
                width: 5px;
            }
            .fss::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 3px;
            }
            .fhr {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 2px 6px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            }
            .fhr:last-child {
                border-bottom: none;
            }
            .fhl {
                font-family: var(--mo);
                font-size: 9px;
                color: var(--td);
                min-width: 100px;
            }
            .fhl strong {
                color: var(--ac);
            }
            .fhc {
                flex: 1;
                height: 32px;
                border-radius: 3px;
            }

            /* Lesson */
            .lp {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: #0c0c14;
                border-top: 1px solid rgba(251, 191, 36, 0.2);
                box-shadow: 0 -6px 30px rgba(0, 0, 0, 0.6);
                z-index: 100;
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                max-height: 240px;
                overflow: hidden;
            }
            .lp.co {
                transform: translateY(calc(100% - 34px));
            }
            .lh {
                display: flex;
                align-items: center;
                gap: 7px;
                padding: 6px 16px;
                cursor: pointer;
                user-select: none;
                background: rgba(251, 191, 36, 0.04);
                border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            }
            .lhi {
                width: 16px;
                height: 16px;
                border-radius: 50%;
                background: var(--am);
                color: var(--bg);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
                font-weight: 700;
                font-family: var(--mo);
                flex-shrink: 0;
            }
            .lht {
                font-family: var(--mo);
                font-size: 10px;
                font-weight: 600;
                color: var(--am);
                flex: 1;
            }
            .lhh {
                font-family: var(--mo);
                font-size: 8px;
                color: var(--tm);
            }
            .lhc {
                font-size: 11px;
                color: var(--td);
                transition: transform 0.3s;
            }
            .lp.co .lhc {
                transform: rotate(180deg);
            }
            .lby {
                padding: 10px 18px 14px;
                overflow-y: auto;
                max-height: 195px;
                line-height: 1.7;
            }
            .lby h3 {
                font-family: var(--sn);
                font-size: 14px;
                font-weight: 600;
                color: var(--am);
                margin-bottom: 5px;
            }
            .lby p {
                font-family: var(--se);
                font-size: 12px;
                color: rgba(255, 255, 255, 0.6);
                margin-bottom: 6px;
            }
            .lby code {
                font-family: var(--mo);
                font-size: 10px;
                color: var(--ac);
                background: rgba(167, 139, 250, 0.1);
                padding: 1px 4px;
                border-radius: 3px;
            }
            .lby .fm {
                font-family: var(--mo);
                font-size: 11px;
                color: var(--gn);
                background: rgba(52, 211, 153, 0.06);
                border: 1px solid rgba(52, 211, 153, 0.12);
                border-radius: 4px;
                padding: 5px 10px;
                margin: 5px 0;
                display: inline-block;
            }
            .lby .kp {
                border-left: 3px solid var(--am);
                padding-left: 10px;
                margin: 6px 0;
                font-family: var(--se);
                font-style: italic;
                color: rgba(255, 255, 255, 0.5);
            }
            /* v6: mode panels */
            .mode-panel {
                margin-top: 10px;
            }
            .mode-panel[style*='display: none'],
            .mode-panel.hidden {
                display: none;
            }
            .band-row {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 8px 10px;
                background: var(--s);
                border: 1px solid var(--bd);
                border-radius: 7px;
                margin-bottom: 6px;
                flex-wrap: wrap;
            }
            .band-row .band-color {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                flex-shrink: 0;
            }
            .band-row .band-ctrls {
                flex: 1;
                min-width: 200px;
            }
            .band-row .band-rm {
                background: none;
                border: 1px solid rgba(251, 113, 133, 0.3);
                color: var(--rs);
                border-radius: 4px;
                padding: 2px 7px;
                cursor: pointer;
                font-family: var(--mo);
                font-size: 9px;
            }
            .band-row .band-rm:hover {
                background: var(--rsd);
            }
            .noise-region {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 6px 10px;
                background: rgba(251, 191, 36, 0.06);
                border: 1px solid rgba(251, 191, 36, 0.15);
                border-radius: 7px;
                margin-bottom: 8px;
                font-family: var(--mo);
                font-size: 10px;
                color: var(--am);
            }
            .inline-edit {
                width: 55px;
                background: transparent;
                border: 1px solid var(--cy);
                border-radius: 3px;
                color: var(--ac);
                font-family: var(--mo);
                font-size: 10px;
                text-align: right;
                padding: 1px 3px;
                outline: none;
            }
            .edu-toggle {
                cursor: pointer;
                user-select: none;
                font-family: var(--mo);
                font-size: 9px;
                padding: 4px 0;
                margin-bottom: 6px;
                display: flex;
                align-items: center;
                gap: 6px;
            }
            .edu-body {
                max-height: 300px;
                opacity: 1;
                padding: 8px 12px;
                transition:
                    max-height 0.3s,
                    opacity 0.2s,
                    padding 0.3s;
                overflow: hidden;
                background: rgba(251, 191, 36, 0.03);
                border: 1px solid rgba(251, 191, 36, 0.1);
                border-radius: 6px;
                margin-bottom: 8px;
            }
            .edu-body.edu-hidden {
                max-height: 0;
                opacity: 0;
                padding: 0 12px;
                border-color: transparent;
            }
            .edu-body h3 {
                font-family: var(--sn);
                font-size: 13px;
                font-weight: 600;
                color: var(--am);
                margin-bottom: 4px;
            }
            .edu-body p {
                font-family: var(--se);
                font-size: 11px;
                color: rgba(255, 255, 255, 0.55);
                margin-bottom: 5px;
                line-height: 1.6;
            }
            .edu-body .fm {
                font-family: var(--mo);
                font-size: 10px;
                color: var(--gn);
                background: rgba(52, 211, 153, 0.06);
                border: 1px solid rgba(52, 211, 153, 0.12);
                border-radius: 4px;
                padding: 4px 8px;
                margin: 4px 0;
                display: inline-block;
            }
            .edu-body .kp {
                border-left: 3px solid var(--am);
                padding-left: 8px;
                margin: 5px 0;
                font-family: var(--se);
                font-style: italic;
                color: rgba(255, 255, 255, 0.45);
                font-size: 11px;
            }
            #wCW {
                position: relative;
                cursor: text;
            }
            #wCW canvas {
                display: block;
                width: 100%;
            }
            #mCW {
                position: relative;
            }
            #mCov {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }
            #mCW.crosshair canvas {
                cursor: crosshair;
            }
            #mCov.active {
                pointer-events: auto;
                cursor: crosshair;
            }
        </style>
    </head>
    <body>
        <div class="ctn">
            <h1>Fourier Explorer</h1>
            <p class="sub">
                Analyze Â· Extract Â· Isolate Â· Listen â€” advanced audio feature
                isolation
            </p>

            <!-- Upload -->
            <div class="sec">
                <div class="sl">Audio Source</div>
                <div
                    id="uz"
                    class="uz"
                    data-l="fi"
                    onclick="
                        $('fin').click();
                        L('fi');
                    "
                >
                    <input
                        type="file"
                        id="fin"
                        accept=".wav,.mp3,.ogg,.flac,.m4a"
                    />
                    <div class="ui">ðŸŽ™</div>
                    <div class="ut">
                        Drop <strong>audio</strong> here or click
                    </div>
                    <div class="uh">WAVÂ·MP3Â·OGGÂ·FLACÂ·M4A</div>
                </div>
                <div id="finfo" class="fi" style="display: none">
                    <span class="fn" id="fname"></span
                    ><span class="fm" id="fmeta"></span
                    ><button onclick="ldP(S.preset || 'tones')">Clear</button>
                </div>
                <div class="pr" style="margin-top: 8px">
                    <div class="sl">Synthetic signals</div>
                    <div class="bg" id="pBtns">
                        <button class="bt ac" data-p="tones" data-l="pre">
                            440+1k+2.5k</button
                        ><button class="bt" data-p="chirp" data-l="pre">
                            Chirp</button
                        ><button class="bt" data-p="impulses" data-l="pre">
                            Impulses</button
                        ><button class="bt" data-p="chord" data-l="pre">
                            C Major</button
                        ><button class="bt" data-p="square" data-l="pre">
                            Square
                        </button>
                    </div>
                </div>
            </div>

            <!-- Transport -->
            <div class="sec">
                <div class="sl">Playback</div>
                <div class="tr">
                    <button
                        class="tb"
                        id="playB"
                        data-l="pb"
                        onclick="
                            togPlay();
                            L('pb');
                        "
                    >
                        â–¶
                    </button>
                    <button class="tb" onclick="stopA()">â– </button>
                    <span class="tt" id="tDisp">0:00.0 / 0:00.0</span>
                    <input
                        type="range"
                        class="ts"
                        id="seek"
                        min="0"
                        max="1000"
                        value="0"
                        step="1"
                    />
                    <div class="at">
                        <span>Listen to</span>
                        <button
                            class="tb"
                            id="extPlayB"
                            onclick="togExtPlay()"
                            title="Toggle: Original vs Extracted (bypass)"
                            style="
                                width: auto;
                                border-radius: 5px;
                                padding: 0 8px;
                                font-size: 9px;
                                font-family: var(--mo);
                            "
                        >
                            ORIGINAL
                        </button>
                    </div>
                    <div
                        class="at"
                        data-l="wetDryCtrl"
                        onclick="L('wetDryCtrl')"
                    >
                        <span>Mix</span>
                        <input
                            type="range"
                            class="ts"
                            id="wetDry"
                            min="0"
                            max="100"
                            value="100"
                            style="width: 60px"
                        />
                        <span class="srv" id="wetDryV" style="min-width: 30px"
                            >100%</span
                        >
                    </div>
                    <div class="at" data-l="extToggle" onclick="L('extToggle')">
                        <span>Overlay</span>
                        <div class="tg cy on" id="ovTog" onclick="togOverlay()">
                            <div class="kn"></div>
                        </div>
                    </div>
                    <div
                        class="at"
                        data-l="anTog"
                        onclick="
                            togAn();
                            L('anTog');
                        "
                    >
                        <span>Analysis</span>
                        <div class="tg on" id="anTog">
                            <div class="kn"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Isolation Mode Selector -->
            <div class="sec" id="bandSec">
                <div class="sl" data-l="isoMode" onclick="L('isoMode')">
                    Isolation Mode
                    <span style="color: var(--cy); font-weight: 400"
                        >Â· cyan = extracted</span
                    >
                </div>
                <div class="bg" id="modeBtns" style="margin-bottom: 10px">
                    <button class="bt ac" data-m="single">Single Band</button>
                    <button class="bt" data-m="multi">Multi-Band</button>
                    <button class="bt" data-m="spectral">Spectral Sub</button>
                    <button class="bt" data-m="combined">Combined</button>
                </div>

                <!-- Panel: Single Band -->
                <div id="panSingle" class="mode-panel">
                    <div
                        class="edu-toggle"
                        onclick="
                            this.nextElementSibling.classList.toggle(
                                'edu-hidden',
                            )
                        "
                    >
                        <span style="color: var(--am)"
                            >? Learn about Single-Band Extraction</span
                        >
                        <span class="lhc">&#9660;</span>
                    </div>
                    <div class="edu-body edu-hidden" id="eduSingle"></div>
                    <div class="cg">
                        <div>
                            <div class="sr">
                                <span class="srl">Low cutoff</span
                                ><input
                                    type="range"
                                    id="bandLo"
                                    min="0"
                                    max="22050"
                                    step="10"
                                    value="0"
                                /><span class="srv" id="bandLoV">0 Hz</span>
                            </div>
                        </div>
                        <div>
                            <div class="sr">
                                <span class="srl">High cutoff</span
                                ><input
                                    type="range"
                                    id="bandHi"
                                    min="0"
                                    max="22050"
                                    step="10"
                                    value="22050"
                                /><span class="srv" id="bandHiV">22050 Hz</span>
                            </div>
                        </div>
                    </div>
                    <div
                        class="sr"
                        data-l="rolloffCtrl"
                        onclick="L('rolloffCtrl')"
                    >
                        <span class="srl">Rolloff (order)</span>
                        <input
                            type="range"
                            id="rolloffS"
                            min="1"
                            max="12"
                            step="1"
                            value="4"
                        />
                        <span class="srv" id="rolloffV">4</span>
                    </div>
                </div>

                <!-- Panel: Multi-Band -->
                <div id="panMulti" class="mode-panel" style="display: none">
                    <div
                        class="edu-toggle"
                        onclick="
                            this.nextElementSibling.classList.toggle(
                                'edu-hidden',
                            )
                        "
                    >
                        <span style="color: var(--am)"
                            >? Learn about Multi-Band Filtering</span
                        >
                        <span class="lhc">&#9660;</span>
                    </div>
                    <div class="edu-body edu-hidden" id="eduMulti"></div>
                    <div
                        id="bandList"
                        data-l="multiBandCtrl"
                        onclick="L('multiBandCtrl')"
                    ></div>
                    <button
                        class="bt"
                        onclick="
                            addBand();
                            L('multiBandCtrl');
                        "
                        style="margin-top: 4px"
                    >
                        + Add Band
                    </button>
                </div>

                <!-- Panel: Spectral Subtraction -->
                <div id="panSpectral" class="mode-panel" style="display: none">
                    <div
                        class="edu-toggle"
                        onclick="
                            this.nextElementSibling.classList.toggle(
                                'edu-hidden',
                            )
                        "
                    >
                        <span style="color: var(--am)"
                            >? Learn about Spectral Subtraction</span
                        >
                        <span class="lhc">&#9660;</span>
                    </div>
                    <div class="edu-body edu-hidden" id="eduSpectral"></div>
                    <div
                        class="sr"
                        data-l="noiseRegion"
                        onclick="L('noiseRegion')"
                    >
                        <span class="srl">Noise start</span>
                        <input
                            type="range"
                            id="noiseStartS"
                            min="0"
                            max="1000"
                            value="0"
                        />
                        <span class="srv" id="noiseStartV">0.00s</span>
                    </div>
                    <div
                        class="sr"
                        data-l="noiseRegion"
                        onclick="L('noiseRegion')"
                    >
                        <span class="srl">Noise end</span>
                        <input
                            type="range"
                            id="noiseEndS"
                            min="0"
                            max="1000"
                            value="100"
                        />
                        <span class="srv" id="noiseEndV">0.20s</span>
                    </div>
                    <button
                        class="bt"
                        id="captureNoiseB"
                        onclick="
                            captureNoise();
                            L('noiseRegion');
                        "
                        style="margin-bottom: 8px"
                    >
                        Capture Noise Profile
                    </button>
                    <span
                        class="srv"
                        id="noiseStatus"
                        style="color: var(--td); margin-left: 8px"
                        >No profile</span
                    >
                    <div
                        class="sr"
                        data-l="overSubCtrl"
                        onclick="L('overSubCtrl')"
                        style="margin-top: 8px"
                    >
                        <span class="srl">Over-sub (&#945;)</span>
                        <input
                            type="range"
                            id="overSubS"
                            min="50"
                            max="400"
                            step="10"
                            value="100"
                        />
                        <span class="srv" id="overSubV">1.0</span>
                    </div>
                    <div
                        class="sr"
                        data-l="specFloorCtrl"
                        onclick="L('specFloorCtrl')"
                    >
                        <span class="srl">Spec floor (&#946;)</span>
                        <input
                            type="range"
                            id="specFloorS"
                            min="1"
                            max="100"
                            step="1"
                            value="10"
                        />
                        <span class="srv" id="specFloorV">0.010</span>
                    </div>
                </div>

                <!-- Panel: Combined -->
                <div id="panCombined" class="mode-panel" style="display: none">
                    <div
                        class="edu-toggle"
                        onclick="
                            this.nextElementSibling.classList.toggle(
                                'edu-hidden',
                            )
                        "
                    >
                        <span style="color: var(--am)"
                            >? Learn about Combined Processing</span
                        >
                        <span class="lhc">&#9660;</span>
                    </div>
                    <div class="edu-body edu-hidden" id="eduCombined"></div>
                    <div
                        class="sl"
                        data-l="combOrderCtrl"
                        onclick="L('combOrderCtrl')"
                        style="margin-top: 6px"
                    >
                        Processing Order
                    </div>
                    <div class="bg" id="orderBtns" style="margin-bottom: 10px">
                        <button class="bt ac" data-o="spectral-first">
                            Spectral Sub &#8594; Band Filter
                        </button>
                        <button class="bt" data-o="band-first">
                            Band Filter &#8594; Spectral Sub
                        </button>
                    </div>
                    <div
                        class="sl"
                        data-l="noiseRegion"
                        onclick="L('noiseRegion')"
                    >
                        Noise Reduction
                    </div>
                    <div
                        class="sr"
                        data-l="noiseRegion"
                        onclick="L('noiseRegion')"
                    >
                        <span class="srl">Noise start</span>
                        <input
                            type="range"
                            id="cNoiseStartS"
                            min="0"
                            max="1000"
                            value="0"
                        />
                        <span class="srv" id="cNoiseStartV">0.00s</span>
                    </div>
                    <div
                        class="sr"
                        data-l="noiseRegion"
                        onclick="L('noiseRegion')"
                    >
                        <span class="srl">Noise end</span>
                        <input
                            type="range"
                            id="cNoiseEndS"
                            min="0"
                            max="1000"
                            value="100"
                        />
                        <span class="srv" id="cNoiseEndV">0.20s</span>
                    </div>
                    <button
                        class="bt"
                        onclick="
                            captureNoise();
                            L('noiseRegion');
                        "
                        style="margin-bottom: 8px"
                    >
                        Capture Noise Profile
                    </button>
                    <span
                        class="srv"
                        id="cNoiseStatus"
                        style="color: var(--td); margin-left: 8px"
                        >No profile</span
                    >
                    <div
                        class="sr"
                        data-l="overSubCtrl"
                        onclick="L('overSubCtrl')"
                        style="margin-top: 8px"
                    >
                        <span class="srl">Over-sub (&#945;)</span>
                        <input
                            type="range"
                            id="cOverSubS"
                            min="50"
                            max="400"
                            step="10"
                            value="100"
                        />
                        <span class="srv" id="cOverSubV">1.0</span>
                    </div>
                    <div
                        class="sr"
                        data-l="specFloorCtrl"
                        onclick="L('specFloorCtrl')"
                    >
                        <span class="srl">Spec floor (&#946;)</span>
                        <input
                            type="range"
                            id="cSpecFloorS"
                            min="1"
                            max="100"
                            step="1"
                            value="10"
                        />
                        <span class="srv" id="cSpecFloorV">0.010</span>
                    </div>
                    <div class="sl" style="margin-top: 10px">Band Filters</div>
                    <div id="cBandList"></div>
                    <button
                        class="bt"
                        onclick="addBand()"
                        style="margin-top: 4px"
                    >
                        + Add Band
                    </button>
                </div>
            </div>

            <!-- Waveform -->
            <div class="sec">
                <div class="sl" data-l="selRegion" onclick="L('selRegion')">
                    Waveform
                    <span
                        style="
                            font-weight: 400;
                            color: var(--gn);
                            font-size: 8px;
                        "
                        >Â· drag to select region</span
                    >
                    <span class="lb" id="livB" style="display: none"
                        ><span class="ld"></span>LIVE</span
                    >
                </div>
                <div class="cw" id="wCW" data-l="wf">
                    <canvas id="wC" height="110"></canvas>
                </div>
                <div class="cc" id="wCap"></div>
                <div class="cc" id="selCap" style="color: var(--gn)"></div>
            </div>

            <!-- Tabs -->
            <div class="tabs" id="mTabs">
                <button class="tab ac" data-t="fft" data-l="fftT">FFT</button>
                <button class="tab" data-t="stft" data-l="stftT">STFT</button>
                <button class="tab" data-t="fs" data-l="fsT">
                    Fourier Series
                </button>
            </div>

            <!-- FFT/STFT Controls -->
            <div id="fsCtrls">
                <div class="cg">
                    <div data-l="wfn" onclick="L('wfn')">
                        <label>Window</label>
                        <div class="bg" id="wBtns">
                            <button class="bt" data-w="rectangular" data-l="wr">
                                rect</button
                            ><button class="bt ac" data-w="hann" data-l="wh">
                                hann</button
                            ><button class="bt" data-w="hamming" data-l="whm">
                                hamming</button
                            ><button class="bt" data-w="blackman" data-l="wb">
                                blackman
                            </button>
                        </div>
                    </div>
                    <div data-l="mf" onclick="L('mf')">
                        <div class="sr">
                            <span class="srl">Max freq</span
                            ><input
                                type="range"
                                id="mfS"
                                min="500"
                                max="22050"
                                step="250"
                                value="8000"
                            /><span class="srv" id="mfV">8000 Hz</span>
                        </div>
                    </div>
                </div>
                <div class="cg">
                    <div data-l="zp" onclick="L('zp')">
                        <label>Zero-Pad</label>
                        <div class="bg" id="zpB">
                            <button class="bt ac" data-z="1">1Ã—</button
                            ><button class="bt" data-z="2">2Ã—</button
                            ><button class="bt" data-z="4">4Ã—</button>
                        </div>
                    </div>
                    <div data-l="dr" onclick="L('dr')">
                        <div class="sr">
                            <span class="srl">Dynamic range</span
                            ><input
                                type="range"
                                id="drS"
                                min="20"
                                max="120"
                                step="5"
                                value="60"
                            /><span class="srv" id="drV">60 dB</span>
                        </div>
                    </div>
                </div>
                <div id="stC" style="display: none">
                    <div class="cg">
                        <div data-l="nf" onclick="L('nf')">
                            <label>n_fft</label>
                            <div class="bg" id="nfB">
                                <button class="bt" data-n="256">256</button
                                ><button class="bt" data-n="512">512</button
                                ><button class="bt ac" data-n="1024">
                                    1024</button
                                ><button class="bt" data-n="2048">2048</button
                                ><button class="bt" data-n="4096">4096</button>
                            </div>
                        </div>
                        <div data-l="ol" onclick="L('ol')">
                            <div class="sr">
                                <span class="srl">Overlap</span
                                ><input
                                    type="range"
                                    id="olS"
                                    min="0"
                                    max="90"
                                    step="5"
                                    value="75"
                                /><span class="srv" id="olV">75%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FS Controls -->
            <div id="fSerC" style="display: none">
                <div class="fsn">
                    <strong>Fourier Series:</strong> Select a window â†’ see it
                    tiled as periodic â†’ watch individual harmonics. Use the
                    harmonics slider to reconstruct progressively.
                </div>
                <div class="cg">
                    <div data-l="fsW" onclick="L('fsW')">
                        <label>Window size</label>
                        <div class="sr">
                            <input
                                type="range"
                                id="fsWS"
                                min="64"
                                max="4096"
                                step="64"
                                value="512"
                            /><span class="srv" id="fsWV">512</span>
                        </div>
                    </div>
                    <div data-l="fsH" onclick="L('fsH')">
                        <label>Harmonics</label>
                        <div class="sr">
                            <input
                                type="range"
                                id="fsHS"
                                min="1"
                                max="64"
                                step="1"
                                value="8"
                            /><span class="srv" id="fsHV">8</span>
                        </div>
                    </div>
                </div>
                <div class="cg">
                    <div data-l="fsO" onclick="L('fsO')">
                        <label>Window offset</label>
                        <div class="sr">
                            <input
                                type="range"
                                id="fsOS"
                                min="0"
                                max="1000"
                                step="1"
                                value="0"
                            /><span class="srv" id="fsOV">0</span>
                        </div>
                    </div>
                    <div></div>
                </div>
            </div>

            <!-- Main viz -->
            <div class="sec">
                <div class="cw" id="mCW">
                    <canvas id="mC" height="300"></canvas>
                    <canvas id="mCov" height="300"></canvas>
                    <div class="aol" id="anOff" style="display: none">
                        Analysis OFF
                    </div>
                </div>
                <div class="cc" id="mCap"></div>
            </div>

            <!-- Live spec -->
            <div class="sec" id="livS" style="display: none">
                <div class="sl">
                    Live Spectrum
                    <span class="lb"><span class="ld"></span>REAL-TIME</span>
                </div>
                <div class="cw"><canvas id="livC" height="150"></canvas></div>
            </div>

            <!-- FS viz -->
            <div id="fsViz" style="display: none">
                <div class="sec">
                    <div class="sl" data-l="fsR" onclick="L('fsR')">
                        Reconstruction
                    </div>
                    <div class="cw">
                        <canvas id="fsRC" height="90"></canvas>
                    </div>
                    <div class="cc" id="fsRCap"></div>
                </div>
                <div class="sec">
                    <div class="sl" data-l="fsHr" onclick="L('fsHr')">
                        Individual Harmonics
                    </div>
                    <div class="fss" id="fsScr"></div>
                </div>
            </div>

            <!-- Params -->
            <div class="sec">
                <div class="sl">
                    Parameters
                    <span
                        style="
                            font-weight: 400;
                            color: var(--am);
                            font-size: 8px;
                        "
                        >click for lesson</span
                    >
                </div>
                <div class="pg" id="pG"></div>
            </div>
            <div class="ft">TECHIN 513A Â· Fourier Transform Fundamentals</div>
        </div>

        <!-- Lesson -->
        <div class="lp" id="lP">
            <div class="lh" onclick="togLP()">
                <div class="lhi">?</div>
                <div class="lht" id="lT">Click any parameter for a lesson</div>
                <div class="lhh">click to toggle</div>
                <div class="lhc" id="lCh">â–¼</div>
            </div>
            <div class="lby" id="lB">
                <h3>Welcome</h3>
                <p>
                    Click any control, slider, button, or parameter card. The
                    <strong>Fourier Series</strong> tab shows signal
                    decomposition into sine waves. The
                    <strong>frequency band</strong> selector lets you isolate
                    and <em>listen to</em> specific frequency ranges â€” click
                    "ORIGINAL" in the transport bar to switch to "EXTRACTED" and
                    hear only the selected band.
                </p>
                <div class="kp">
                    Space = play/pause Â· Esc = stop Â· A = analysis toggle Â· E =
                    extraction toggle
                </div>
            </div>
        </div>

        <script>
            const $ = id => document.getElementById(id);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LESSONS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const LS = {
                wf: {
                    t: 'Waveform',
                    b: '<h3>Waveform</h3><p>Amplitude vs time. When the <span style="color:#22d3ee">cyan overlay</span> is on, the extracted frequency band is drawn on top of the original (blue) waveform. This lets you visually see which parts of the signal fall within your selected band.</p><p><strong>Region selection:</strong> Drag horizontally to select a time region (green edges). Playback will loop within this region. Double-click to clear. Click to seek.</p><div class="kp">The audio you hear during "ORIGINAL" mode is unchanged. In "EXTRACTED" mode, you hear only the cyan portion â€” everything outside your band has been removed via inverse FFT.</div>',
                },
                fftT: {
                    t: 'FFT',
                    b: '<h3>FFT</h3><p>Decomposes the signal into frequency bins. The <span style="color:#22d3ee">cyan highlighted region</span> on the spectrum shows your selected extraction band. Everything inside this band can be isolated and played back.</p><div class="fm">X[k] = Î£ x[n] Â· e^(-jÂ·2Ï€Â·kÂ·n/N)</div>',
                },
                stftT: {
                    t: 'STFT',
                    b: '<h3>STFT</h3><p>Spectrogram view. The extraction band appears as a <span style="color:#22d3ee">cyan horizontal band</span> overlaid on the spectrogram, showing which frequencies are being extracted at every time step.</p>',
                },
                fsT: {
                    t: 'Fourier Series',
                    b: '<h3>Fourier Series</h3><p>Decomposes a periodic window into individual sine waves. Each harmonic is shown separately. The reconstruction (green) converges on the original (white) as you add harmonics.</p><div class="kp">In "EXTRACTED" playback mode with the Fourier Series tab, you hear the reconstruction from the selected number of harmonics â€” letting you hear what each harmonic contributes.</div>',
                },
                bandSel: {
                    t: 'Frequency Band Extraction',
                    b: '<h3>Band Extraction</h3><p>This is the core new feature. Set a low and high frequency cutoff to define a <em>bandpass filter</em>. The tool computes the FFT of your entire signal, zeros out all bins outside this range, then inverse-FFTs back to get the filtered audio.</p><p>Toggle the playback to <strong>EXTRACTED</strong> to hear only the frequencies in your band. The <span style="color:#22d3ee">cyan overlay</span> on the waveform shows this filtered signal in real time.</p><div class="kp">Try isolating 400-500 Hz on the three-tone preset â€” you\'ll hear only the 440 Hz component. Or on a real recording, isolate 2000-4000 Hz to hear just the high-frequency content like sibilance, hissing, or the snap of percussive sounds.</div>',
                },
                extToggle: {
                    t: 'Extraction Overlay',
                    b: '<h3>Overlay Toggle</h3><p>When on, the extracted (bandpass-filtered) signal is drawn in <span style="color:#22d3ee">cyan</span> over the original blue waveform. This visual overlay lets you see exactly which parts of the audio fall within your selected frequency band.</p><p>Loud regions of cyan = lots of energy in your band. Regions where cyan is flat but blue is active = energy outside your band.</p>',
                },
                anTog: {
                    t: 'Analysis Toggle',
                    b: '<h3>Analysis On/Off</h3><p>Toggles the FFT/STFT visualization. Audio playback and extraction still work with analysis off.</p>',
                },
                pb: {
                    t: 'Playback',
                    b: '<h3>Playback & Extraction</h3><p>The "ORIGINAL / EXTRACTED" button switches what you <em>hear</em>:</p><p><strong>ORIGINAL:</strong> The unmodified audio signal.</p><p><strong>EXTRACTED:</strong> Only the frequencies within your selected band (bandpass filtered via inverse FFT). In Fourier Series mode, you hear the reconstruction from the selected harmonics.</p><div class="kp">This is where analysis becomes tangible. You\'re not just seeing frequency content â€” you\'re hearing it isolated. This is conceptually identical to what NMF source separation does in your project: decompose a signal into components, then reconstruct only the ones you want.</div>',
                },
                nf: {
                    t: 'n_fft',
                    b: '<h3>n_fft (FFT Window Size)</h3><p>The fundamental time-frequency tradeoff parameter. Controls how many samples are analyzed in each STFT frame.</p><div class="fm">Î”f = fs / n_fft &nbsp;&nbsp;|&nbsp;&nbsp; Î”t = hop / fs</div><p><strong>256:</strong> ~5.8ms windows at 44.1kHz. Excellent time resolution, poor frequency resolution (172 Hz bins). Good for transient sounds like drum hits.</p><p><strong>1024:</strong> ~23ms windows. Balanced time/frequency tradeoff. Good default.</p><p><strong>4096:</strong> ~93ms windows. Excellent frequency resolution (10.8 Hz bins), but time events are smeared. Good for sustained tones, chords, machinery hum.</p><div class="kp">The Heisenberg-Gabor uncertainty principle: you cannot have both perfect time and frequency resolution simultaneously. Î”f Ã— Î”t â‰¥ 1/(4Ï€). This is a fundamental limit, not a software limitation.</div>',
                },
                ol: {
                    t: 'Overlap',
                    b: '<h3>Overlap Percentage</h3><p>How much consecutive STFT frames overlap in time.</p><div class="fm">hop = n_fft Ã— (1 - overlap%)</div><p><strong>75% (default):</strong> hop = n_fft/4. Standard for Hann window â€” ensures perfect reconstruction and smooth time axis.</p><p><strong>50%:</strong> hop = n_fft/2. Fewer frames, coarser time resolution, but faster computation.</p><p><strong>90%:</strong> Very smooth spectrogram with many frames. Useful for detailed time analysis but computationally expensive.</p><div class="kp">With a Hann window, 75% overlap provides "constant overlap-add" (COLA) â€” meaning if you sum all the windowed frames, you recover the original signal perfectly. This is essential for proper STFT analysis.</div>',
                },
                wfn: {
                    t: 'Window Function',
                    b: '<h3>Window Functions</h3><p>Tapers signal edges to prevent <strong>spectral leakage</strong>. The FFT assumes the signal is periodic â€” without windowing, discontinuities at frame edges cause energy to "leak" into neighboring frequency bins.</p><div class="fm">windowed_signal[n] = signal[n] Ã— window[n]</div><p>The window multiplies each sample, tapering smoothly to zero at the edges. This reduces leakage at the cost of slightly widening frequency peaks (the "main lobe").</p><div class="kp">The tradeoff: narrower main lobe = better frequency resolution but more leakage. Wider main lobe = less leakage but blurred frequency peaks. Hann is the best general-purpose choice.</div>',
                },
                wr: {
                    t: 'Rectangular',
                    b: '<h3>Rectangular Window</h3><p>No taper at all â€” every sample weighted equally. Equivalent to no windowing.</p><p><strong>Main lobe width:</strong> Narrowest (best resolution).</p><p><strong>Sidelobe level:</strong> -13 dB (worst leakage).</p><div class="kp">Only useful when the signal is guaranteed to be exactly periodic within the frame (rare in practice). For real-world audio, spectral leakage makes rectangular almost useless.</div>',
                },
                wh: {
                    t: 'Hann',
                    b: '<h3>Hann Window</h3><p>The go-to window for general audio analysis. Named after Julius von Hann (sometimes incorrectly called "Hanning").</p><div class="fm">w[n] = 0.5 Ã— (1 - cos(2Ï€n / (N-1)))</div><p><strong>Sidelobe level:</strong> -31 dB with fast rolloff.</p><p><strong>Main lobe:</strong> Moderate width.</p><div class="kp">Use Hann unless you have a specific reason not to. It provides the best balance of leakage suppression and frequency resolution for most audio analysis tasks.</div>',
                },
                whm: {
                    t: 'Hamming',
                    b: '<h3>Hamming Window</h3><p>Similar to Hann but with a small pedestal â€” the window doesn\'t quite reach zero at the edges.</p><div class="fm">w[n] = 0.54 - 0.46 Ã— cos(2Ï€n / (N-1))</div><p><strong>Sidelobe level:</strong> -42 dB (better first sidelobe than Hann).</p><p><strong>Rolloff:</strong> Slower than Hann for distant sidelobes.</p><div class="kp">Traditional default in speech processing (e.g., MFCCs, formant analysis). The non-zero edges can cause issues with overlap-add reconstruction.</div>',
                },
                wb: {
                    t: 'Blackman',
                    b: '<h3>Blackman Window</h3><p>Three-term cosine window with the strongest sidelobe suppression of the four options here.</p><div class="fm">w[n] = 0.42 - 0.5cos(2Ï€n/(N-1)) + 0.08cos(4Ï€n/(N-1))</div><p><strong>Sidelobe level:</strong> -58 dB (excellent suppression).</p><p><strong>Main lobe:</strong> Widest â€” frequency peaks are most blurred.</p><div class="kp">Use when you need very clean spectra with minimal leakage (e.g., identifying weak tones near strong ones). The wider main lobe means you may need a larger FFT to compensate for lost resolution.</div>',
                },
                zp: {
                    t: 'Zero-Padding',
                    b: '<h3>Zero-Padding</h3><p>Appends zeros to the signal before FFT, increasing the number of output bins.</p><p><strong>2Ã—:</strong> Doubles bins â€” interpolates between existing values for smoother appearance.</p><p><strong>4Ã—:</strong> Quadruples bins â€” very smooth spectral envelope.</p><div class="kp">Important: zero-padding does NOT improve real frequency resolution (Î”f is still fs/N_original). It only interpolates between the bins you already have. Think of it as "upsampling" the frequency axis. Useful for visualization and peak detection, but don\'t mistake the smoother curve for actual new information.</div>',
                },
                dr: {
                    t: 'Dynamic Range',
                    b: '<h3>Dynamic Range</h3><p>Controls the dB floor for the display. Only affects visualization, not the actual data.</p><p><strong>40 dB:</strong> Shows signals down to 1/100th of peak amplitude. Good for strong, clean signals.</p><p><strong>60 dB:</strong> Shows down to 1/1000th. Good default.</p><p><strong>90-120 dB:</strong> Shows very quiet components. Useful for finding weak harmonics or noise floor.</p><div class="kp">If the spectrogram looks mostly bright, decrease the range. If it looks mostly dark, increase it. The goal is to see meaningful structure.</div>',
                },
                mf: {
                    t: 'Max Frequency',
                    b: '<h3>Max Display Frequency</h3><p>Crops the frequency axis display. Does not affect analysis â€” just zooms into the range you care about.</p><p>Most useful audio content lives below 8 kHz:</p><p><strong>Speech fundamentals:</strong> 80-300 Hz<br><strong>Speech formants:</strong> 300-3500 Hz<br><strong>Music fundamentals:</strong> 30-4000 Hz<br><strong>Household sounds:</strong> 50-8000 Hz<br><strong>Sibilance/cymbals:</strong> 6000-16000 Hz</p><div class="kp">For the construction audio, try 50-8000 Hz to focus on hammering, sawing, and motor sounds.</div>',
                },
                pre: {
                    t: 'Presets',
                    b: '<h3>Synthetic Signal Presets</h3><p>Clean, mathematically defined signals for learning and testing:</p><p><strong>440+1k+2.5k Hz:</strong> Three pure sine waves. Perfect for testing band extraction â€” isolate each tone by setting the band around its frequency. Try 400-500 Hz to hear only the 440 Hz component.</p><p><strong>Chirp:</strong> Frequency sweep from 100 to 4000 Hz. Shows as a diagonal line on the STFT spectrogram â€” a great visual demo of time-frequency analysis.</p><p><strong>Impulses:</strong> Periodic clicks with exponential decay. Broadband energy (all frequencies at once). Tests how your filter handles transients.</p><p><strong>C Major:</strong> Six-note chord with harmonics. Rich harmonic structure visible in Fourier Series mode.</p><p><strong>Square:</strong> Square wave at 200 Hz. Only odd harmonics (200, 600, 1000, 1400...) â€” the missing even harmonics are visible in the Fourier Series decomposition.</p>',
                },
                fi: {
                    t: 'File Input',
                    b: '<h3>Audio File Loading</h3><p>Supports WAV, MP3, OGG, FLAC, and M4A formats. The browser\'s Web Audio API handles decoding.</p><p><strong>Stereo â†’ Mono:</strong> Multi-channel audio is automatically mixed down to mono (averaged across channels).</p><p><strong>Duration limit:</strong> 30 seconds maximum. Longer files are truncated. This keeps FFT computation fast enough for interactive use.</p><p><strong>Sample rate:</strong> Preserved from the original file. All frequency limits (Nyquist, max display freq, band cutoffs) automatically adjust to match.</p><div class="kp">For best results with feature isolation, use recordings where the target sound (e.g., hammering) is clearly present. The extraction tools work on frequency content â€” they can\'t separate sounds that occupy the exact same frequencies.</div>',
                },
                pfs: {
                    t: 'Sample Rate',
                    b: '<h3>Sample Rate (fs)</h3><p>The number of amplitude measurements taken per second. Determines the maximum frequency that can be represented.</p><div class="fm">fs samples/second</div><p><strong>44,100 Hz:</strong> CD quality. Captures frequencies up to 22,050 Hz â€” well above human hearing range (~20 kHz).</p><p><strong>48,000 Hz:</strong> Professional audio/video standard.</p><div class="kp">The sample rate is fixed by the audio file. All other frequency parameters (Nyquist, band cutoffs, frequency resolution) derive from it.</div>',
                },
                pny: {
                    t: 'Nyquist',
                    b: '<h3>Nyquist Frequency</h3><p>The highest frequency that can be represented at a given sample rate. Named after Harry Nyquist.</p><div class="fm">f_Nyquist = fs / 2</div><p>Frequencies above this limit would "alias" â€” appear as phantom lower frequencies. This is why the band cutoff sliders stop at Nyquist.</p><div class="kp">The Shannon-Nyquist theorem: to faithfully capture a frequency f, you must sample at â‰¥ 2f. At 44.1 kHz, the max is 22,050 Hz.</div>',
                },
                pN: {
                    t: 'N (Total Samples)',
                    b: '<h3>N â€” Total Samples</h3><p>The total number of amplitude values in the loaded signal.</p><div class="fm">Duration = N / fs</div><p>For a 2-second signal at 44.1 kHz: N = 88,200 samples. This is also the FFT size when computing the full-signal spectrum (non-STFT mode).</p>',
                },
                pdf: {
                    t: 'Î”f',
                    b: '<h3>Î”f â€” Frequency Resolution</h3><p>The spacing between adjacent frequency bins in the FFT output.</p><div class="fm">Î”f = fs / N_fft</div><p>Smaller Î”f = you can distinguish closer frequencies. But achieving smaller Î”f requires a longer FFT window, which blurs time resolution.</p><p><strong>Example:</strong> At 44.1 kHz with n_fft=1024: Î”f = 43.1 Hz. Two tones at 440 Hz and 460 Hz (20 Hz apart) would fall in the same bin and be indistinguishable. With n_fft=4096: Î”f = 10.8 Hz â€” now they\'re in separate bins.</p>',
                },
                pdt: {
                    t: 'Î”t',
                    b: '<h3>Î”t â€” Time Resolution</h3><p>The time between consecutive STFT frames (spectrogram columns).</p><div class="fm">Î”t = hop / fs = n_fft Ã— (1 - overlap%) / fs</div><p>Smaller Î”t = finer time resolution, more frames to compute. At n_fft=1024, 75% overlap, 44.1 kHz: Î”t â‰ˆ 5.8ms â€” each spectrogram column represents ~6ms of audio.</p>',
                },
                pbn: {
                    t: 'Bins',
                    b: '<h3>Frequency Bins</h3><p>The number of unique frequency values in the FFT output.</p><div class="fm">bins = N_fft / 2 + 1</div><p>Due to the symmetry of real-valued FFT, only the first half of the output is unique (plus the DC and Nyquist bins). With n_fft=1024: 513 bins from 0 Hz to Nyquist.</p>',
                },
                pfr: {
                    t: 'Frames',
                    b: '<h3>Time Frames</h3><p>The number of columns in the spectrogram â€” each one is a separate FFT of an overlapping window.</p><div class="fm">frames â‰ˆ (N - n_fft) / hop + 1</div><p>More frames = finer time axis but slower computation. Controlled by n_fft and overlap percentage.</p>',
                },
                psh: {
                    t: 'Shape',
                    b: '<h3>Spectrogram Shape</h3><p>The dimensions of the spectrogram matrix: bins Ã— frames. This is the 2D data structure that the STFT produces.</p><p>Each cell contains the magnitude (or dB value) at a specific frequency and time. The colormap maps these values to pixel colors.</p>',
                },
                fsW: {
                    t: 'FS Window',
                    b: '<h3>Fourier Series â€” Window Size</h3><p>The number of samples treated as one period of the signal. This determines the fundamental frequency:</p><div class="fm">fâ‚ = fs / window_size</div><p>All harmonics are integer multiples of fâ‚. Larger window = lower fundamental = more harmonics available for reconstruction.</p><div class="kp">The Fourier Series assumes the window is one complete period that repeats forever. This is different from the FFT, which analyzes the signal as a whole. The "tiled" view shows this periodic assumption â€” the window is repeated left and right.</div>',
                },
                fsH: {
                    t: 'Harmonics',
                    b: '<h3>Fourier Series â€” Number of Harmonics</h3><p>How many sine/cosine components to include in the reconstruction (k = 0 to k = harmonics).</p><p><strong>k=0:</strong> DC offset (average value).</p><p><strong>k=1:</strong> Fundamental frequency fâ‚.</p><p><strong>k=2,3,...:</strong> Overtones at 2fâ‚, 3fâ‚, etc.</p><p>Watch the green reconstruction converge on the white original as you add more harmonics. This is Fourier\'s insight: <em>any</em> periodic signal can be decomposed into a sum of sines and cosines.</p><div class="kp">For a square wave, you need many harmonics (odd only: 1, 3, 5, 7...) to approximate the sharp edges. The "Gibbs phenomenon" â€” the persistent overshoot near discontinuities â€” never fully goes away no matter how many harmonics you add.</div>',
                },
                fsO: {
                    t: 'Offset',
                    b: '<h3>Window Offset Position</h3><p>Where in the audio signal to grab the window for Fourier Series analysis. Drag to slide the analysis window through the signal.</p><p>The orange-highlighted region on the waveform shows the current window position. Different positions capture different local frequency content.</p><div class="kp">For a signal with changing frequency content (like the chirp preset), moving the offset changes which harmonics are detected. For a stationary signal (like the tones preset), all positions give similar results.</div>',
                },
                fsR: {
                    t: 'Reconstruction',
                    b: '<h3>Fourier Series Reconstruction</h3><p><strong>White line:</strong> Original signal within the selected window.</p><p><strong>Green line:</strong> Sum of the first k harmonics (reconstruction).</p><p>As you increase the number of harmonics, the green line converges toward the white line. With enough harmonics, the reconstruction becomes indistinguishable from the original.</p><p>In EXTRACTED playback mode with the Fourier Series tab active, you hear this green reconstruction tiled across the full signal duration.</p>',
                },
                fsHr: {
                    t: 'Individual Harmonics',
                    b: '<h3>Individual Harmonics</h3><p>Each row shows one harmonic component â€” a single sine wave at frequency k Ã— fâ‚:</p><p><strong>k=0:</strong> DC component (flat line at the signal\'s average value).</p><p><strong>k=1:</strong> Fundamental â€” the lowest frequency, one complete cycle per window.</p><p><strong>k=2+:</strong> Overtones â€” integer multiples of the fundamental. Progressively higher frequencies, often progressively smaller amplitudes.</p><p>The amplitude and phase of each harmonic are extracted via FFT of the windowed signal. The color of each trace matches its position in the harmonic series.</p><div class="kp">In a rich musical tone (like the C Major chord), you\'ll see significant energy at many harmonics. In a pure sine wave, only k=1 has energy. The distribution of energy across harmonics is what gives sounds their unique "timbre" or character.</div>',
                },
                // v6 lessons
                isoMode: {
                    t: 'Isolation Mode',
                    b: '<h3>Isolation Modes</h3><p>Four different approaches to extracting sounds from audio:</p><p><strong>Single Band:</strong> Classic bandpass filter with smooth Butterworth rolloff. Best for isolating a single frequency range (e.g., just the bass, just the highs).</p><p><strong>Multi-Band:</strong> Define multiple frequency ranges simultaneously. Essential for sounds that span several frequency regions (e.g., a hammer strike has both low thud and high crack).</p><p><strong>Spectral Subtraction:</strong> Estimate background noise from a quiet section, then subtract it from the entire signal. Great for denoising.</p><p><strong>Combined:</strong> Chain spectral subtraction with multi-band filtering for maximum isolation power.</p><div class="kp">Each mode has its own collapsible educational panel â€” click "? Learn about this mode" to expand it.</div>',
                },
                wetDryCtrl: {
                    t: 'Wet/Dry Mix',
                    b: '<h3>Wet/Dry Mix</h3><p>Controls the blend between original ("dry") and processed ("wet") audio:</p><p><strong>0%:</strong> 100% original signal, no extraction applied.</p><p><strong>50%:</strong> Equal mix of original and extracted.</p><p><strong>100%:</strong> Fully extracted/processed signal only.</p><div class="fm">output = (1 - mix) Ã— original + mix Ã— extracted</div><p>The ORIGINAL/EXTRACTED toggle acts as a bypass â€” it instantly mutes/unmutes the extraction without moving the mix slider. This lets you A/B compare at any mix level.</p><div class="kp">Tip: Sweep the mix slider slowly while listening to hear exactly how the extraction changes the audio character. Values around 70-90% often sound more natural than 100% because they retain some original context.</div>',
                },
                rolloffCtrl: {
                    t: 'Filter Rolloff',
                    b: '<h3>Butterworth Rolloff Order</h3><p>Controls how sharply the filter transitions from passband (full signal) to stopband (silence). This is the "N" in the Butterworth formula:</p><div class="fm">|H(f)| = 1 / sqrt(1 + (f/fc)^(2N))</div><p>Each unit of order adds approximately <strong>20 dB/decade</strong> of rolloff steepness:</p><p><strong>Order 1:</strong> Very gentle â€” frequencies near the cutoff are only slightly attenuated. Good for subtle shaping.</p><p><strong>Order 4:</strong> Standard â€” a good balance between sharpness and smoothness.</p><p><strong>Order 8-12:</strong> Very sharp â€” approaches a brick-wall filter. Can cause "ringing" (oscillation near the cutoff) on transient sounds like drum hits.</p><div class="kp">The amber gain curve on the FFT plot shows the exact filter shape. Watch how it changes as you adjust the order.</div>',
                },
                noiseRegion: {
                    t: 'Noise Region',
                    b: '<h3>Noise Region Selection</h3><p>Spectral subtraction needs a reference: what does "just noise" sound like? Select a portion of the audio that contains <em>only</em> background noise (no target sounds).</p><p><strong>Noise start/end:</strong> Define the time range. The orange-highlighted region on the waveform shows your selection.</p><p><strong>Capture Noise Profile:</strong> Computes the FFT of the selected region and stores its magnitude spectrum as the noise template.</p><div class="kp">Tips for good noise profiles:<br>â€¢ Choose at least 0.2 seconds of noise<br>â€¢ Pick a section with consistent, representative noise<br>â€¢ Avoid sections with any target sounds (even faint ones)<br>â€¢ If results are poor, try a different noise section</div>',
                },
                overSubCtrl: {
                    t: 'Over-subtraction',
                    b: '<h3>Over-subtraction Factor (Î±)</h3><p>Multiplier applied to the noise magnitude before subtraction:</p><div class="fm">|S_clean| = |S| - Î± Ã— |N|</div><p><strong>Î± = 1.0:</strong> Subtracts exactly the estimated noise level. Starting point.</p><p><strong>Î± > 1.0:</strong> Subtracts more aggressively. Removes more noise but risks distorting the target signal.</p><p><strong>Î± < 1.0:</strong> Gentle subtraction. Some noise remains but less distortion risk.</p><div class="kp">Common range: 1.0 to 2.5. Start at 1.0, increase if noise persists, decrease if the target sounds distorted or "underwater."</div>',
                },
                specFloorCtrl: {
                    t: 'Spectral Floor',
                    b: '<h3>Spectral Floor (Î²)</h3><p>Minimum magnitude floor to prevent negative values after subtraction:</p><div class="fm">|S_clean| = max(|S| - Î±Ã—|N|, Î² Ã— |S|)</div><p>Without this floor, some frequency bins would go to zero or negative, creating artifacts called <strong>"musical noise"</strong> â€” random chirpy, tonal artifacts.</p><p><strong>Î² = 0.01:</strong> Low floor â€” more noise removed but risk of musical noise.</p><p><strong>Î² = 0.05-0.1:</strong> Higher floor â€” smoother result, some noise leaks through.</p><div class="kp">If you hear chirpy/watery artifacts, increase Î². If too much noise remains, decrease Î² (and possibly increase Î± to compensate).</div>',
                },
                combOrderCtrl: {
                    t: 'Processing Order',
                    b: '<h3>Processing Order</h3><p>When combining spectral subtraction with band filtering, the order matters:</p><p><strong>Spectral Sub â†’ Band Filter:</strong> First denoise the full signal, then extract frequency bands from the clean signal. Best for:</p><ul style="color:rgba(255,255,255,.5);font-size:11px;margin:4px 0 4px 16px"><li>Broadband noise (hiss, wind, HVAC hum)</li><li>When noise and target overlap in frequency</li></ul><p><strong>Band Filter â†’ Spectral Sub:</strong> First isolate your bands of interest, then denoise within those bands. Best for:</p><ul style="color:rgba(255,255,255,.5);font-size:11px;margin:4px 0 4px 16px"><li>When target is in a specific frequency range</li><li>Reduces computational cost (denoising smaller signal)</li></ul>',
                },
                selRegion: {
                    t: 'Waveform Selection',
                    b: '<h3>Region Selection</h3><p>Drag on the waveform to select a time region. Playback (both original and extracted) will be confined to this region.</p><p><strong>Drag:</strong> Click and drag horizontally to select a region (shown with green edges and dimmed outside areas).</p><p><strong>Click:</strong> Single click to seek the playhead to that position.</p><p><strong>Double-click:</strong> Clear the selection (play full audio again).</p><div class="kp">This is powerful for isolating specific events â€” select just the moment a hammer strikes, then compare original vs extracted to hear how well your filter settings capture that specific sound.</div>',
                },
                multiBandCtrl: {
                    t: 'Multi-Band Controls',
                    b: '<h3>Multi-Band Filter Controls</h3><p>Each band defines an independent frequency range to extract:</p><p><strong>Low/High cutoff:</strong> Frequency boundaries of the band.</p><p><strong>Rolloff:</strong> Butterworth order for this specific band (each band can have different sharpness).</p><p><strong>+ Add Band:</strong> Create a new band with default settings.</p><p><strong>âœ• Remove:</strong> Delete a band.</p><p>Bands are combined using <strong>maximum gain</strong> (union) at each frequency â€” overlapping bands don\'t amplify.</p><div class="kp">On the STFT spectrogram tab, you can also click-drag to create bands visually. Hold Shift to add bands instead of replacing.</div>',
                },
            };
            // â”€â”€ EDUCATIONAL CONTENT (v6) â”€â”€
            const EDU = {
                single: '<h3>Single-Band Extraction (Butterworth Rolloff)</h3><p>A bandpass filter passes frequencies within a range and attenuates those outside. Unlike the simple brick-wall approach (which abruptly zeros out bins), a Butterworth filter applies a smooth gain curve that gradually rolls off.</p><div class="fm">|H(f)| = 1 / sqrt(1 + (f/fc)^(2N))</div><p><strong>Rolloff order (N)</strong> controls the steepness of the transition:</p><div class="kp">Order 1: gentle slope (~20 dB/decade). Order 4: standard. Order 12: nearly brick-wall. Higher orders give sharper cutoffs but can introduce ringing artifacts on transient sounds.</div><p>The amber curve on the FFT plot shows the actual filter gain shape. Try adjusting the order while listening to extracted audio to hear the difference.</p>',
                multi: '<h3>Multi-Band Filtering</h3><p>Real-world sounds span multiple frequency regions. A hammer strike has a low-frequency thud (100-500 Hz) <em>and</em> a high-frequency crack (2-6 kHz). Single-band filtering can only capture one region at a time.</p><p>Multi-band mode lets you define several frequency bands, each with its own cutoff frequencies and rolloff. The combined output uses the <strong>maximum gain</strong> across all bands at each frequency bin (union, not sum), preventing amplification of overlapping regions.</p><div class="kp">Tip: On the STFT tab, click-drag to select a band visually. Hold Shift to add additional bands. Each band gets its own color on the spectrogram.</div>',
                spectral:
                    '<h3>Spectral Subtraction</h3><p>Instead of selecting which frequencies to <em>keep</em>, spectral subtraction estimates the <em>noise</em> and removes it. The process:</p><p>1. Select a quiet section of audio (just background noise)<br>2. Capture its frequency profile<br>3. Subtract that profile from the entire signal</p><div class="fm">|S_clean(f)| = max( |S(f)| - Î±Â·|N(f)|, Î²Â·|S(f)| )</div><p><strong>Over-subtraction (Î±):</strong> Values above 1.0 remove more noise but risk distorting the target signal. Start at 1.0 and increase if noise remains.</p><p><strong>Spectral floor (Î²):</strong> Prevents the result from going below Î² Ã— original magnitude. Too low â†’ "musical noise" (chirpy artifacts from random residual bins). Too high â†’ noise leaks through.</p><div class="kp">This is the same principle used in professional noise reduction (e.g., Audacity\'s noise reduction, iZotope RX). The quality depends heavily on having a good noise profile from a representative quiet section.</div>',
                combined:
                    '<h3>Combined: Spectral Subtraction + Multi-Band</h3><p>Chain both techniques for maximum isolation power. The processing order matters:</p><p><strong>Spectral Sub â†’ Band Filter:</strong> First clean noise from the entire signal, then extract your target frequency bands from the cleaned audio. Best when noise is broadband (hiss, hum, ambient rumble).</p><p><strong>Band Filter â†’ Spectral Sub:</strong> First isolate your bands of interest, then apply noise reduction within those bands. Better when noise is concentrated in the same frequency region as your target sound.</p><div class="kp">For construction audio: try Spectral-first to remove ambient noise, then define bands around hammer-strike frequencies (200-800 Hz for thud, 2-5 kHz for impact crack).</div>',
            };
            let lCol = false;
            function L(k) {
                const l = LS[k];
                if (!l) return;
                $('lT').textContent = l.t;
                $('lB').innerHTML = l.b;
                if (lCol) {
                    lCol = false;
                    $('lP').classList.remove('co');
                }
            }
            function togLP() {
                lCol = !lCol;
                $('lP').classList.toggle('co', lCol);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DSP
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function gW(t, sz) {
                const w = new Float64Array(sz);
                for (let n = 0; n < sz; n++) {
                    switch (t) {
                        case 'rectangular':
                            w[n] = 1;
                            break;
                        case 'hann':
                            w[n] =
                                0.5 *
                                (1 - Math.cos((2 * Math.PI * n) / (sz - 1)));
                            break;
                        case 'hamming':
                            w[n] =
                                0.54 -
                                0.46 * Math.cos((2 * Math.PI * n) / (sz - 1));
                            break;
                        case 'blackman':
                            w[n] =
                                0.42 -
                                0.5 * Math.cos((2 * Math.PI * n) / (sz - 1)) +
                                0.08 * Math.cos((4 * Math.PI * n) / (sz - 1));
                            break;
                    }
                }
                return w;
            }
            function fI(re, im) {
                const n = re.length;
                if (n <= 1) return;
                for (let i = 1, j = 0; i < n; i++) {
                    let b = n >> 1;
                    for (; j & b; b >>= 1) j ^= b;
                    j ^= b;
                    if (i < j) {
                        [re[i], re[j]] = [re[j], re[i]];
                        [im[i], im[j]] = [im[j], im[i]];
                    }
                }
                for (let l = 2; l <= n; l <<= 1) {
                    const a = (-2 * Math.PI) / l,
                        wR = Math.cos(a),
                        wI = Math.sin(a);
                    for (let i = 0; i < n; i += l) {
                        let cR = 1,
                            cI = 0;
                        for (let j = 0; j < l / 2; j++) {
                            const uR = re[i + j],
                                uI = im[i + j],
                                vR =
                                    re[i + j + l / 2] * cR -
                                    im[i + j + l / 2] * cI,
                                vI =
                                    re[i + j + l / 2] * cI +
                                    im[i + j + l / 2] * cR;
                            re[i + j] = uR + vR;
                            im[i + j] = uI + vI;
                            re[i + j + l / 2] = uR - vR;
                            im[i + j + l / 2] = uI - vI;
                            const nR = cR * wR - cI * wI;
                            cI = cR * wI + cI * wR;
                            cR = nR;
                        }
                    }
                }
            }
            function ifI(re, im) {
                const n = re.length;
                for (let i = 0; i < n; i++) im[i] = -im[i];
                fI(re, im);
                for (let i = 0; i < n; i++) {
                    re[i] /= n;
                    im[i] = -im[i] / n;
                }
            }

            function fftSlice(sig, st, sz, wt, zp) {
                let n = 1;
                while (n < sz * zp) n <<= 1;
                const w = gW(wt, sz),
                    re = new Float64Array(n),
                    im = new Float64Array(n);
                for (let i = 0; i < sz; i++) {
                    const idx = st + i;
                    if (idx >= 0 && idx < sig.length) re[i] = sig[idx] * w[i];
                }
                fI(re, im);
                const h = n / 2 + 1,
                    m = new Float64Array(h);
                for (let i = 0; i < h; i++)
                    m[i] = Math.sqrt(re[i] * re[i] + im[i] * im[i]);
                return { mag: m, n };
            }
            function fullFFT(sig, wt, sr, zp) {
                let n = 1;
                while (n < sig.length * zp) n <<= 1;
                const w = gW(wt, sig.length),
                    re = new Float64Array(n),
                    im = new Float64Array(n);
                for (let i = 0; i < sig.length; i++) re[i] = sig[i] * w[i];
                fI(re, im);
                const h = n / 2 + 1,
                    m = new Float64Array(h),
                    f = new Float64Array(h);
                for (let i = 0; i < h; i++) {
                    m[i] = Math.sqrt(re[i] * re[i] + im[i] * im[i]);
                    f[i] = (i * sr) / n;
                }
                return { mag: m, freqs: f, n };
            }
            function compSTFT(sig, nf, hp, wt, zp) {
                const w = gW(wt, nf);
                let fs = 1;
                while (fs < nf * zp) fs <<= 1;
                const nfr = Math.max(1, Math.floor((sig.length - nf) / hp) + 1),
                    nb = fs / 2 + 1,
                    sp = [];
                for (let f = 0; f < nfr; f++) {
                    const s = f * hp,
                        re = new Float64Array(fs),
                        im = new Float64Array(fs);
                    for (let i = 0; i < nf && s + i < sig.length; i++)
                        re[i] = sig[s + i] * w[i];
                    fI(re, im);
                    const m = new Float64Array(nb);
                    for (let i = 0; i < nb; i++)
                        m[i] = Math.sqrt(re[i] * re[i] + im[i] * im[i]);
                    sp.push(m);
                }
                return { spec: sp, numBins: nb, numFrames: nfr, fftSize: fs };
            }

            // â”€â”€ BANDPASS FILTER via FFT (legacy brick-wall) â”€â”€
            function bandpassFilter(sig, sr, loHz, hiHz) {
                let n = 1;
                while (n < sig.length) n <<= 1;
                const re = new Float64Array(n),
                    im = new Float64Array(n);
                for (let i = 0; i < sig.length; i++) re[i] = sig[i];
                fI(re, im);
                const binLo = Math.floor((loHz * n) / sr),
                    binHi = Math.ceil((hiHz * n) / sr);
                for (let i = 0; i < n; i++) {
                    if (i <= n / 2) {
                        if (i < binLo || i > binHi) {
                            re[i] = 0;
                            im[i] = 0;
                        }
                    } else {
                        const mirror = n - i;
                        if (mirror < binLo || mirror > binHi) {
                            re[i] = 0;
                            im[i] = 0;
                        }
                    }
                }
                ifI(re, im);
                const out = new Float64Array(sig.length);
                for (let i = 0; i < sig.length; i++) out[i] = re[i];
                return out;
            }

            // â”€â”€ BUTTERWORTH GAIN â”€â”€
            function butterworthGain(f, fc, order, isHighpass) {
                if (isHighpass) {
                    if (f <= 0) return 0;
                    return 1 / Math.sqrt(1 + Math.pow(fc / f, 2 * order));
                } else {
                    if (fc <= 0) return 0;
                    return 1 / Math.sqrt(1 + Math.pow(f / fc, 2 * order));
                }
            }

            // â”€â”€ SMOOTH BANDPASS (Butterworth) â”€â”€
            function smoothBandpass(sig, sr, loHz, hiHz, order) {
                let n = 1;
                while (n < sig.length) n <<= 1;
                const re = new Float64Array(n),
                    im = new Float64Array(n);
                for (let i = 0; i < sig.length; i++) re[i] = sig[i];
                fI(re, im);
                for (let i = 0; i <= n / 2; i++) {
                    const freq = (i * sr) / n;
                    let gain = 1;
                    if (loHz > 0)
                        gain *= butterworthGain(freq, loHz, order, true);
                    if (hiHz < sr / 2)
                        gain *= butterworthGain(freq, hiHz, order, false);
                    re[i] *= gain;
                    im[i] *= gain;
                    if (i > 0 && i < n / 2) {
                        re[n - i] *= gain;
                        im[n - i] *= gain;
                    }
                }
                ifI(re, im);
                const out = new Float64Array(sig.length);
                for (let i = 0; i < sig.length; i++) out[i] = re[i];
                return out;
            }

            // â”€â”€ MULTI-BAND FILTER â”€â”€
            function multiBandFilter(sig, sr, bands) {
                if (!bands.length) return sig.slice();
                let n = 1;
                while (n < sig.length) n <<= 1;
                const re = new Float64Array(n),
                    im = new Float64Array(n);
                for (let i = 0; i < sig.length; i++) re[i] = sig[i];
                fI(re, im);
                const outRe = new Float64Array(n),
                    outIm = new Float64Array(n);
                for (let i = 0; i <= n / 2; i++) {
                    const freq = (i * sr) / n;
                    let maxGain = 0;
                    for (const b of bands) {
                        let g = 1;
                        if (b.lo > 0)
                            g *= butterworthGain(
                                freq,
                                b.lo,
                                b.rolloff || 4,
                                true,
                            );
                        if (b.hi < sr / 2)
                            g *= butterworthGain(
                                freq,
                                b.hi,
                                b.rolloff || 4,
                                false,
                            );
                        if (g > maxGain) maxGain = g;
                    }
                    outRe[i] = re[i] * maxGain;
                    outIm[i] = im[i] * maxGain;
                    if (i > 0 && i < n / 2) {
                        outRe[n - i] = re[n - i] * maxGain;
                        outIm[n - i] = im[n - i] * maxGain;
                    }
                }
                ifI(outRe, outIm);
                const out = new Float64Array(sig.length);
                for (let i = 0; i < sig.length; i++) out[i] = outRe[i];
                return out;
            }

            // â”€â”€ SPECTRAL SUBTRACTION â”€â”€
            function captureNoise() {
                if (!S.sig) return;
                const s = Math.floor(S.noiseStart * S.sig.length);
                const e = Math.floor(S.noiseEnd * S.sig.length);
                const len = e - s;
                if (len < 256) {
                    alert(
                        'Select a longer noise region (at least 256 samples)',
                    );
                    return;
                }
                let n = 1;
                while (n < len) n <<= 1;
                const re = new Float64Array(n),
                    im = new Float64Array(n);
                for (let i = 0; i < len; i++) re[i] = S.sig[s + i];
                fI(re, im);
                const profile = new Float64Array(n / 2 + 1);
                for (let i = 0; i <= n / 2; i++)
                    profile[i] = Math.sqrt(re[i] * re[i] + im[i] * im[i]);
                S.noiseProfile = profile;
                S.noiseFFTSize = n;
                const st = $('noiseStatus');
                if (st) st.textContent = 'Captured (' + len + ' samples)';
                const cs = $('cNoiseStatus');
                if (cs) cs.textContent = 'Captured (' + len + ' samples)';
                recomputeExtraction();
                if (!S.playing) rAll();
            }

            function spectralSubtract(
                sig,
                sr,
                noiseProfile,
                noiseFftSize,
                alpha,
                beta,
            ) {
                let n = 1;
                while (n < sig.length) n <<= 1;
                const re = new Float64Array(n),
                    im = new Float64Array(n);
                for (let i = 0; i < sig.length; i++) re[i] = sig[i];
                fI(re, im);
                const halfN = n / 2;
                const halfNoise = noiseFftSize / 2;
                for (let i = 0; i <= halfN; i++) {
                    const mag = Math.sqrt(re[i] * re[i] + im[i] * im[i]);
                    const phase = Math.atan2(im[i], re[i]);
                    const nIdx = Math.min(
                        Math.round((i / halfN) * halfNoise),
                        noiseProfile.length - 1,
                    );
                    const noiseMag = noiseProfile[nIdx] || 0;
                    let cleanMag = mag - alpha * noiseMag;
                    cleanMag = Math.max(cleanMag, beta * mag);
                    re[i] = cleanMag * Math.cos(phase);
                    im[i] = cleanMag * Math.sin(phase);
                    if (i > 0 && i < halfN) {
                        re[n - i] = cleanMag * Math.cos(-phase);
                        im[n - i] = cleanMag * Math.sin(-phase);
                    }
                }
                ifI(re, im);
                const out = new Float64Array(sig.length);
                for (let i = 0; i < sig.length; i++) out[i] = re[i];
                return out;
            }

            // â”€â”€ Fourier Series â”€â”€
            function compFS(sig, st, ws) {
                const chunk = new Float64Array(ws);
                for (let i = 0; i < ws; i++) {
                    const idx = st + i;
                    chunk[i] = idx >= 0 && idx < sig.length ? sig[idx] : 0;
                }
                let n = 1;
                while (n < ws) n <<= 1;
                const re = new Float64Array(n),
                    im = new Float64Array(n);
                for (let i = 0; i < ws; i++) re[i] = chunk[i];
                fI(re, im);
                const mH = Math.min(Math.floor(ws / 2), 256),
                    h = [];
                for (let k = 0; k <= mH; k++) {
                    const amp =
                        k === 0
                            ? Math.sqrt(re[0] * re[0] + im[0] * im[0]) / ws
                            : (2 * Math.sqrt(re[k] * re[k] + im[k] * im[k])) /
                              ws;
                    h.push({ k, amp, phase: Math.atan2(im[k], re[k]) });
                }
                // Build reconstruction audio for playback
                return { harmonics: h, chunk, re, im, n: n };
            }

            function reconstructFS(harmonics, ws, numH) {
                const out = new Float64Array(ws);
                for (let k = 0; k <= numH && k < harmonics.length; k++) {
                    const h = harmonics[k];
                    for (let i = 0; i < ws; i++) {
                        const t = i / ws;
                        out[i] +=
                            k === 0
                                ? h.amp * Math.cos(h.phase)
                                : h.amp *
                                  Math.cos(2 * Math.PI * k * t + h.phase);
                    }
                }
                return out;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GENERATORS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function gTones(fs, d) {
                const N = Math.floor(fs * d),
                    s = new Float64Array(N);
                for (let i = 0; i < N; i++) {
                    const t = i / fs;
                    s[i] =
                        0.7 * Math.sin(2 * Math.PI * 440 * t) +
                        0.5 * Math.sin(2 * Math.PI * 1e3 * t) +
                        0.3 * Math.sin(2 * Math.PI * 2500 * t) +
                        0.05 * (Math.random() * 2 - 1);
                }
                return s;
            }
            function gChirp(fs, d) {
                const N = Math.floor(fs * d),
                    s = new Float64Array(N);
                for (let i = 0; i < N; i++) {
                    const t = i / fs;
                    s[i] =
                        0.8 *
                        Math.sin(
                            2 * Math.PI * (100 * t + (0.5 * 3900 * t * t) / d),
                        );
                }
                return s;
            }
            function gImp(fs, d) {
                const N = Math.floor(fs * d),
                    s = new Float64Array(N),
                    iv = Math.floor(fs * 0.35);
                for (let i = 0; i < N; i++) {
                    const m = i % iv;
                    if (m < Math.floor(fs * 0.012))
                        s[i] = 0.9 * Math.exp(-m / (fs * 0.003));
                }
                return s;
            }
            function gChord(fs, d) {
                const f = [261.63, 329.63, 392, 523.25, 659.25, 784],
                    a = [0.5, 0.4, 0.45, 0.25, 0.2, 0.22],
                    N = Math.floor(fs * d),
                    s = new Float64Array(N);
                for (let i = 0; i < N; i++) {
                    const t = i / fs;
                    for (let j = 0; j < f.length; j++)
                        s[i] += a[j] * Math.sin(2 * Math.PI * f[j] * t);
                    s[i] += 0.03 * (Math.random() * 2 - 1);
                }
                return s;
            }
            function gSq(fs, d) {
                const N = Math.floor(fs * d),
                    s = new Float64Array(N);
                for (let i = 0; i < N; i++)
                    s[i] =
                        Math.sin((2 * Math.PI * 200 * i) / fs) >= 0
                            ? 0.8
                            : -0.8;
                return s;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // COLORMAP
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const MG = [
                [0, 0, 4],
                [1, 0, 11],
                [3, 1, 22],
                [7, 2, 36],
                [14, 4, 52],
                [24, 6, 68],
                [38, 9, 82],
                [53, 12, 90],
                [68, 15, 94],
                [84, 18, 96],
                [100, 22, 96],
                [116, 25, 93],
                [132, 29, 89],
                [149, 33, 84],
                [165, 38, 79],
                [181, 44, 73],
                [196, 51, 67],
                [210, 60, 60],
                [222, 72, 53],
                [232, 86, 46],
                [240, 101, 39],
                [246, 118, 33],
                [250, 136, 29],
                [252, 155, 27],
                [252, 174, 30],
                [250, 194, 39],
                [247, 214, 55],
                [244, 233, 79],
                [245, 249, 107],
                [252, 253, 191],
            ];
            function mc(v) {
                const t = Math.max(0, Math.min(1, v)),
                    i = t * (MG.length - 1),
                    l = Math.floor(i),
                    h = Math.min(l + 1, MG.length - 1),
                    f = i - l;
                return [
                    Math.round(MG[l][0] + (MG[h][0] - MG[l][0]) * f),
                    Math.round(MG[l][1] + (MG[h][1] - MG[l][1]) * f),
                    Math.round(MG[l][2] + (MG[h][2] - MG[l][2]) * f),
                ];
            }
            const HC = [
                '#f87171',
                '#fb923c',
                '#fbbf24',
                '#a3e635',
                '#34d399',
                '#22d3ee',
                '#60a5fa',
                '#a78bfa',
                '#e879f9',
                '#fb7185',
                '#f97316',
                '#facc15',
                '#4ade80',
                '#2dd4bf',
                '#38bdf8',
                '#818cf8',
                '#c084fc',
            ];

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // STATE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const S = {
                sig: null,
                sr: 44100,
                lbl: '',
                preset: 'tones',
                tab: 'fft',
                wt: 'hann',
                mf: 8e3,
                nfft: 1024,
                olP: 75,
                zpR: 1,
                dynR: 60,
                anOn: true,
                playing: false,
                pSt: 0,
                pOff: 0,
                dur: 0,
                aCtx: null,
                sN: null,
                aBuf: null,
                aF: null,
                stD: null,
                fsW: 512,
                fsH: 8,
                fsOff: 0,
                bLo: 0,
                bHi: 22050,
                extSig: null,
                extBuf: null,
                playExt: false,
                showOv: true,
                fsSig: null,
                fsBuf: null,
                // v6: region selection (fraction of full signal, 0-1)
                selStart: 0,
                selEnd: 1,
                hasSelection: false,
                // v6: isolation modes
                isoMode: 'single',
                rolloff: 4,
                wetDry: 1.0,
                prevWetDry: 1.0,
                bands: [{ lo: 200, hi: 2000, rolloff: 4 }],
                noiseProfile: null,
                noiseFFTSize: 0,
                noiseStart: 0,
                noiseEnd: 0.1,
                overSub: 1.0,
                specFloor: 0.01,
                combOrder: 'spectral-first',
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // EXTRACTION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function recomputeExtraction() {
                if (!S.sig) return;
                if (S.tab === 'fs') {
                    const off = Math.floor(
                        (S.fsOff / 1000) * Math.max(0, S.sig.length - S.fsW),
                    );
                    const { harmonics, chunk } = compFS(S.sig, off, S.fsW);
                    const recon = reconstructFS(harmonics, S.fsW, S.fsH);
                    const out = new Float64Array(S.sig.length);
                    for (let i = 0; i < out.length; i++)
                        out[i] = recon[i % S.fsW];
                    S.fsSig = out;
                    S.fsBuf = null;
                } else {
                    switch (S.isoMode) {
                        case 'single':
                            S.extSig = smoothBandpass(
                                S.sig,
                                S.sr,
                                S.bLo,
                                S.bHi,
                                S.rolloff,
                            );
                            break;
                        case 'multi':
                            S.extSig = multiBandFilter(S.sig, S.sr, S.bands);
                            break;
                        case 'spectral':
                            if (S.noiseProfile) {
                                S.extSig = spectralSubtract(
                                    S.sig,
                                    S.sr,
                                    S.noiseProfile,
                                    S.noiseFFTSize,
                                    S.overSub,
                                    S.specFloor,
                                );
                            } else {
                                S.extSig = S.sig.slice();
                            }
                            break;
                        case 'combined': {
                            let processed = S.sig;
                            if (S.combOrder === 'spectral-first') {
                                if (S.noiseProfile)
                                    processed = spectralSubtract(
                                        processed,
                                        S.sr,
                                        S.noiseProfile,
                                        S.noiseFFTSize,
                                        S.overSub,
                                        S.specFloor,
                                    );
                                if (S.bands.length > 0)
                                    processed = multiBandFilter(
                                        processed,
                                        S.sr,
                                        S.bands,
                                    );
                            } else {
                                if (S.bands.length > 0)
                                    processed = multiBandFilter(
                                        processed,
                                        S.sr,
                                        S.bands,
                                    );
                                if (S.noiseProfile)
                                    processed = spectralSubtract(
                                        processed,
                                        S.sr,
                                        S.noiseProfile,
                                        S.noiseFFTSize,
                                        S.overSub,
                                        S.specFloor,
                                    );
                            }
                            S.extSig = processed;
                            break;
                        }
                    }
                    S.extBuf = null;
                }
            }

            function getPlaySig() {
                const orig = S.sig;
                if (!orig) return null;
                let ext;
                if (S.tab === 'fs') {
                    ext = S.fsSig || orig;
                } else {
                    ext = S.extSig || orig;
                }
                // Blend original and extracted based on wet/dry
                let mixed;
                if (!S.playExt || S.wetDry <= 0.0) {
                    mixed = orig;
                } else if (S.wetDry >= 1.0) {
                    mixed = ext;
                } else {
                    mixed = new Float64Array(orig.length);
                    const w = S.wetDry;
                    for (let i = 0; i < orig.length; i++)
                        mixed[i] = (1 - w) * orig[i] + w * ext[i];
                }
                return mixed;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // AUDIO
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function ensCtx() {
                if (!S.aCtx)
                    S.aCtx = new (
                        window.AudioContext || window.webkitAudioContext
                    )();
                if (S.aCtx.state === 'suspended') S.aCtx.resume();
                return S.aCtx;
            }
            function buildBuf(sig) {
                const c = ensCtx(),
                    b = c.createBuffer(1, sig.length, S.sr),
                    ch = b.getChannelData(0);
                for (let i = 0; i < sig.length; i++)
                    ch[i] = Math.max(-1, Math.min(1, sig[i]));
                return b;
            }

            function togPlay() {
                S.playing ? pauseA() : startA();
            }
            function startA() {
                if (!S.sig || !S.sig.length) return;
                ensCtx();
                const ps = getPlaySig();
                if (!ps) return;
                const buf = buildBuf(ps);
                // Duration is always from full signal
                S.dur = S.sig.length / S.sr;
                // Determine play region
                const regStart = S.hasSelection ? S.selStart * S.dur : 0;
                const regEnd = S.hasSelection ? S.selEnd * S.dur : S.dur;
                // If playhead is outside region or at end, reset to region start
                if (S.pOff < regStart || S.pOff >= regEnd - 0.01)
                    S.pOff = regStart;
                const s = S.aCtx.createBufferSource();
                s.buffer = buf;
                s.connect(S.aCtx.destination);
                const playDuration = regEnd - S.pOff;
                s.onended = () => {
                    if (S.playing) {
                        S.playing = false;
                        S.pOff = S.hasSelection ? regStart : S.dur;
                        updTr();
                        stopAL();
                        if (!S.playing) rAll();
                    }
                };
                s.start(0, S.pOff, playDuration);
                S.sN = s;
                S.pSt = S.aCtx.currentTime;
                S.playing = true;
                updTr();
                startAL();
            }
            function pauseA() {
                if (!S.playing) return;
                S.pOff = curT();
                if (S.sN) {
                    try {
                        S.sN.stop();
                    } catch (e) {}
                    S.sN = null;
                }
                S.playing = false;
                updTr();
                stopAL();
                rFr();
            }
            function stopA() {
                if (S.sN) {
                    try {
                        S.sN.stop();
                    } catch (e) {}
                    S.sN = null;
                }
                S.playing = false;
                S.pOff = S.hasSelection ? S.selStart * S.dur : 0;
                updTr();
                stopAL();
                rAll();
            }
            function curT() {
                if (!S.playing) return S.pOff;
                return Math.min(S.pOff + S.aCtx.currentTime - S.pSt, S.dur);
            }
            function seekTo(f) {
                const w = S.playing;
                if (w) {
                    if (S.sN) {
                        try {
                            S.sN.stop();
                        } catch (e) {}
                        S.sN = null;
                    }
                    S.playing = false;
                }
                S.pOff = f * S.dur;
                w ? startA() : (updTr(), rFr());
            }
            function fmtT(s) {
                const m = Math.floor(s / 60),
                    sc = s - m * 60;
                return m + ':' + sc.toFixed(1).padStart(4, '0');
            }
            function updTr() {
                const b = $('playB');
                b.textContent = S.playing ? 'â¸' : 'â–¶';
                b.classList.toggle('pl', S.playing && !S.playExt);
                b.classList.toggle('ext', S.playing && S.playExt);
                $('livB').style.display = S.playing ? '' : 'none';
                $('livS').style.display =
                    S.playing && S.anOn && S.tab !== 'fs' ? '' : 'none';
            }

            function togExtPlay() {
                const was = S.playing;
                if (was) pauseA();
                S.playExt = !S.playExt;
                $('extPlayB').textContent = S.playExt
                    ? 'EXTRACTED'
                    : 'ORIGINAL';
                $('extPlayB').classList.toggle('ext', S.playExt);
                if (was) startA();
            }

            // â”€â”€ MODE SWITCHING â”€â”€
            function switchMode(mode) {
                S.isoMode = mode;
                document
                    .querySelectorAll('#modeBtns .bt')
                    .forEach(b =>
                        b.classList.toggle('ac', b.dataset.m === mode),
                    );
                $('panSingle').style.display = mode === 'single' ? '' : 'none';
                $('panMulti').style.display = mode === 'multi' ? '' : 'none';
                $('panSpectral').style.display =
                    mode === 'spectral' ? '' : 'none';
                $('panCombined').style.display =
                    mode === 'combined' ? '' : 'none';
                renderBands();
                recomputeExtraction();
                if (!S.playing) rAll();
            }

            // â”€â”€ MULTI-BAND UI â”€â”€
            function addBand(lo, hi) {
                const ny = S.sr / 2;
                S.bands.push({
                    lo: lo !== undefined ? Math.round(lo) : 200,
                    hi: hi !== undefined ? Math.round(hi) : 2000,
                    rolloff: 4,
                });
                renderBands();
                recomputeExtraction();
                if (!S.playing) rAll();
            }
            function removeBand(idx) {
                S.bands.splice(idx, 1);
                renderBands();
                recomputeExtraction();
                if (!S.playing) rAll();
            }
            function renderBands() {
                const container =
                    S.isoMode === 'combined' ? $('cBandList') : $('bandList');
                const other =
                    S.isoMode === 'combined' ? $('bandList') : $('cBandList');
                if (other) other.innerHTML = '';
                if (!container) return;
                container.innerHTML = '';
                const ny = S.sr / 2;
                S.bands.forEach((b, idx) => {
                    const col = HC[idx % HC.length];
                    const row = document.createElement('div');
                    row.className = 'band-row';
                    row.innerHTML = `
                        <div class="band-color" style="background:${col}"></div>
                        <div class="band-ctrls">
                            <div class="sr">
                                <span class="srl">Low</span>
                                <input type="range" min="0" max="${ny}" step="10" value="${b.lo}" data-idx="${idx}" data-f="lo" />
                                <span class="srv band-val" data-idx="${idx}" data-f="lo">${b.lo} Hz</span>
                            </div>
                            <div class="sr">
                                <span class="srl">High</span>
                                <input type="range" min="0" max="${ny}" step="10" value="${b.hi}" data-idx="${idx}" data-f="hi" />
                                <span class="srv band-val" data-idx="${idx}" data-f="hi">${b.hi} Hz</span>
                            </div>
                            <div class="sr">
                                <span class="srl">Rolloff</span>
                                <input type="range" min="1" max="12" step="1" value="${b.rolloff}" data-idx="${idx}" data-f="rolloff" />
                                <span class="srv band-val" data-idx="${idx}" data-f="rolloff">${b.rolloff}</span>
                            </div>
                        </div>
                        <button class="band-rm" onclick="removeBand(${idx})">âœ•</button>
                    `;
                    row.querySelectorAll('input[type=range]').forEach(inp => {
                        inp.addEventListener('input', e => {
                            const i = +e.target.dataset.idx,
                                f = e.target.dataset.f;
                            S.bands[i][f] = +e.target.value;
                            const vEl = row.querySelector(
                                `.band-val[data-idx="${i}"][data-f="${f}"]`,
                            );
                            if (vEl)
                                vEl.textContent =
                                    e.target.value +
                                    (f === 'rolloff' ? '' : ' Hz');
                            recomputeExtraction();
                            if (!S.playing) rAll();
                        });
                    });
                    container.appendChild(row);
                });
            }

            // â”€â”€ EDITABLE NUMBER VALUES â”€â”€
            function makeEditable(el, opts) {
                el.style.cursor = 'pointer';
                el.title = 'Double-click to type exact value';
                el.addEventListener('dblclick', function (e) {
                    e.stopPropagation();
                    const current = parseFloat(el.textContent);
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = isNaN(current) ? 0 : current;
                    input.className = 'inline-edit';
                    el.textContent = '';
                    el.appendChild(input);
                    input.focus();
                    input.select();
                    function commit() {
                        let v = parseFloat(input.value);
                        if (isNaN(v)) v = current;
                        v = Math.max(opts.min, Math.min(opts.max, v));
                        if (opts.step)
                            v = Math.round(v / opts.step) * opts.step;
                        el.textContent =
                            (opts.fmt ? opts.fmt(v) : v) + (opts.suffix || '');
                        opts.onChange(v);
                    }
                    input.addEventListener('keydown', ev => {
                        if (ev.key === 'Enter') {
                            ev.preventDefault();
                            commit();
                        }
                        if (ev.key === 'Escape') {
                            el.textContent =
                                (opts.fmt ? opts.fmt(current) : current) +
                                (opts.suffix || '');
                        }
                        ev.stopPropagation();
                    });
                    input.addEventListener('blur', commit);
                });
            }

            function togOverlay() {
                S.showOv = !S.showOv;
                $('ovTog').classList.toggle('on', S.showOv);
                if (!S.playing) rAll();
            }
            function togAn() {
                S.anOn = !S.anOn;
                $('anTog').classList.toggle('on', S.anOn);
                $('livS').style.display =
                    S.playing && S.anOn && S.tab !== 'fs' ? '' : 'none';
                if (!S.playing) rAll();
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ANIMATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function startAL() {
                function lp() {
                    if (!S.playing) return;
                    rFr();
                    S.aF = requestAnimationFrame(lp);
                }
                S.aF = requestAnimationFrame(lp);
            }
            function stopAL() {
                if (S.aF) {
                    cancelAnimationFrame(S.aF);
                    S.aF = null;
                }
            }
            function rFr() {
                const t = curT(),
                    f = S.dur > 0 ? t / S.dur : 0;
                $('seek').value = Math.round(f * 1000);
                $('tDisp').textContent = fmtT(t) + ' / ' + fmtT(S.dur);
                dWave(f);
                if (S.tab === 'fs') dFS();
                else if (S.anOn) {
                    S.tab === 'fft' ? dFFT(f) : dSTFT(f);
                    if (S.playing) dLive(t);
                } else dOff();
            }
            function rAll() {
                const f = S.dur > 0 ? S.pOff / S.dur : 0;
                $('seek').value = Math.round(f * 1000);
                $('tDisp').textContent = fmtT(S.pOff) + ' / ' + fmtT(S.dur);
                dWave(f);
                if (S.tab === 'fs') dFS();
                else if (S.anOn) {
                    S.tab === 'fft' ? dFFT(f) : dSTFT(f);
                } else dOff();
                $('livS').style.display =
                    S.playing && S.anOn && S.tab !== 'fs' ? '' : 'none';
                updP();
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DRAWING
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function gC(id, h) {
                const c = $(id),
                    dp = devicePixelRatio || 1,
                    r = c.parentElement.getBoundingClientRect(),
                    W = r.width;
                c.width = W * dp;
                c.height = h * dp;
                c.style.height = h + 'px';
                const cx = c.getContext('2d');
                cx.scale(dp, dp);
                return { cx, W, H: h };
            }

            function dWave(pf) {
                const { cx, W, H } = gC('wC', 110);
                cx.fillStyle = '#0a0a0f';
                cx.fillRect(0, 0, W, H);
                if (!S.sig) return;
                const sig = S.sig;
                // FS window highlight
                if (S.tab === 'fs') {
                    const off = Math.floor(
                        (S.fsOff / 1000) * Math.max(0, sig.length - S.fsW),
                    );
                    const x0 = (off / sig.length) * W,
                        x1 = ((off + S.fsW) / sig.length) * W;
                    cx.fillStyle = 'rgba(251,191,36,.08)';
                    cx.fillRect(x0, 0, x1 - x0, H);
                    cx.strokeStyle = 'rgba(251,191,36,.3)';
                    cx.lineWidth = 1;
                    cx.strokeRect(x0, 0, x1 - x0, H);
                }
                // Noise region highlight
                if (
                    (S.isoMode === 'spectral' || S.isoMode === 'combined') &&
                    S.tab !== 'fs'
                ) {
                    const nx0 = S.noiseStart * W,
                        nx1 = S.noiseEnd * W;
                    cx.fillStyle = 'rgba(251,191,36,.08)';
                    cx.fillRect(nx0, 0, nx1 - nx0, H);
                    cx.strokeStyle = 'rgba(251,191,36,.25)';
                    cx.lineWidth = 1;
                    cx.setLineDash([3, 3]);
                    cx.strokeRect(nx0, 0, nx1 - nx0, H);
                    cx.setLineDash([]);
                    cx.font = '8px "DM Mono",monospace';
                    cx.fillStyle = 'rgba(251,191,36,.5)';
                    cx.textAlign = 'center';
                    cx.fillText('noise', (nx0 + nx1) / 2, 10);
                }
                // Original waveform
                cx.beginPath();
                cx.strokeStyle = '#3b82f6';
                cx.lineWidth = 0.7;
                const step = Math.max(1, Math.floor(sig.length / W));
                for (let px = 0; px < W; px++) {
                    const idx = Math.floor((px / W) * sig.length);
                    let mn = 1e9,
                        mx = -1e9;
                    for (let j = 0; j < step && idx + j < sig.length; j++) {
                        mn = Math.min(mn, sig[idx + j]);
                        mx = Math.max(mx, sig[idx + j]);
                    }
                    const y1 = H / 2 - mx * H * 0.44,
                        y2 = H / 2 - mn * H * 0.44;
                    px === 0 ? cx.moveTo(px, y1) : 0;
                    cx.lineTo(px, y1);
                    cx.lineTo(px, y2);
                }
                cx.stroke();
                // Extraction overlay
                const ext = S.tab === 'fs' ? S.fsSig : S.extSig;
                if (S.showOv && ext && ext.length === sig.length) {
                    cx.beginPath();
                    cx.strokeStyle = 'rgba(34,211,238,.65)';
                    cx.lineWidth = 0.9;
                    for (let px = 0; px < W; px++) {
                        const idx = Math.floor((px / W) * ext.length);
                        let mn = 1e9,
                            mx = -1e9;
                        for (let j = 0; j < step && idx + j < ext.length; j++) {
                            mn = Math.min(mn, ext[idx + j]);
                            mx = Math.max(mx, ext[idx + j]);
                        }
                        const y1 = H / 2 - mx * H * 0.44,
                            y2 = H / 2 - mn * H * 0.44;
                        px === 0 ? cx.moveTo(px, y1) : 0;
                        cx.lineTo(px, y1);
                        cx.lineTo(px, y2);
                    }
                    cx.stroke();
                }
                // Center line
                cx.strokeStyle = 'rgba(255,255,255,.05)';
                cx.lineWidth = 0.5;
                cx.beginPath();
                cx.moveTo(0, H / 2);
                cx.lineTo(W, H / 2);
                cx.stroke();
                // Selection region
                if (S.hasSelection) {
                    const sx0 = S.selStart * W,
                        sx1 = S.selEnd * W;
                    // Dim areas outside selection
                    cx.fillStyle = 'rgba(0,0,0,.45)';
                    cx.fillRect(0, 0, sx0, H);
                    cx.fillRect(sx1, 0, W - sx1, H);
                    // Selection edges
                    cx.strokeStyle = 'rgba(52,211,153,.7)';
                    cx.lineWidth = 1.5;
                    cx.beginPath();
                    cx.moveTo(sx0, 0);
                    cx.lineTo(sx0, H);
                    cx.stroke();
                    cx.beginPath();
                    cx.moveTo(sx1, 0);
                    cx.lineTo(sx1, H);
                    cx.stroke();
                    // Selection label
                    cx.font = '8px "DM Mono",monospace';
                    cx.fillStyle = 'rgba(52,211,153,.6)';
                    cx.textAlign = 'center';
                    const selDur =
                        (S.selEnd - S.selStart) * (sig.length / S.sr);
                    cx.fillText(
                        selDur.toFixed(2) + 's selected',
                        (sx0 + sx1) / 2,
                        10,
                    );
                }
                // Playhead
                if (pf >= 0 && S.tab !== 'fs') {
                    const x = pf * W;
                    cx.strokeStyle = S.playing
                        ? S.playExt
                            ? '#22d3ee'
                            : '#34d399'
                        : 'rgba(167,139,250,.6)';
                    cx.lineWidth = S.playing ? 2 : 1.5;
                    cx.beginPath();
                    cx.moveTo(x, 0);
                    cx.lineTo(x, H);
                    cx.stroke();
                }
                // Legend
                cx.font = '9px "DM Mono",monospace';
                cx.textAlign = 'left';
                cx.fillStyle = '#3b82f6';
                cx.fillText('â–  original', 6, H - 4);
                if (S.showOv && ext) {
                    cx.fillStyle = '#22d3ee';
                    cx.fillText('â–  extracted', 70, H - 4);
                }
                if (S.hasSelection) {
                    cx.fillStyle = '#34d399';
                    cx.fillText(
                        'â–  selected',
                        S.showOv && ext ? 150 : 70,
                        H - 4,
                    );
                }
                $('wCap').textContent =
                    `${S.lbl} Â· ${sig.length.toLocaleString()} Â· ${S.sr} Hz Â· ${(sig.length / S.sr).toFixed(2)}s`;
                // Selection detail caption
                const selCapEl = $('selCap');
                if (selCapEl) {
                    if (S.hasSelection) {
                        const sT = ((S.selStart * sig.length) / S.sr).toFixed(
                            3,
                        );
                        const eT = ((S.selEnd * sig.length) / S.sr).toFixed(3);
                        const dur = (
                            ((S.selEnd - S.selStart) * sig.length) /
                            S.sr
                        ).toFixed(3);
                        selCapEl.textContent = `Selection: ${sT}s â€” ${eT}s (${dur}s) Â· Drag waveform to select Â· Double-click to clear`;
                    } else {
                        selCapEl.textContent =
                            'Drag on waveform to select a region for playback';
                    }
                }
            }

            function dFFT(pf) {
                $('anOff').style.display = 'none';
                const { cx, W, H } = gC('mC', 280);
                cx.fillStyle = '#0a0a0f';
                cx.fillRect(0, 0, W, H);
                if (!S.sig) return;
                let mag, freqs, n;
                if (pf > 0 && pf < 1) {
                    const c = Math.floor(pf * S.sig.length),
                        st = Math.max(0, c - Math.floor(S.nfft / 2));
                    const r = fftSlice(S.sig, st, S.nfft, S.wt, S.zpR);
                    mag = r.mag;
                    n = r.n;
                    freqs = new Float64Array(mag.length);
                    for (let i = 0; i < mag.length; i++)
                        freqs[i] = (i * S.sr) / n;
                } else {
                    const r = fullFFT(S.sig, S.wt, S.sr, S.zpR);
                    mag = r.mag;
                    freqs = r.freqs;
                    n = r.n;
                }
                const dm = Math.min(S.mf, S.sr / 2);
                let mxD = -1e9;
                const mD = [];
                for (let i = 0; i < mag.length; i++) {
                    const d = 20 * Math.log10(mag[i] + 1e-10);
                    if (d > mxD) mxD = d;
                    mD.push(d);
                }
                const mnD = mxD - S.dynR;
                const p = { l: 48, r: 12, t: 12, b: 30 },
                    pW = W - p.l - p.r,
                    pH = H - p.t - p.b;
                // Band highlight(s)
                if (S.isoMode === 'multi' || S.isoMode === 'combined') {
                    S.bands.forEach((b, idx) => {
                        const col = HC[idx % HC.length];
                        const bx0 = p.l + (b.lo / dm) * pW,
                            bx1 = p.l + (Math.min(b.hi, dm) / dm) * pW;
                        cx.fillStyle = col + '12';
                        cx.fillRect(
                            Math.max(bx0, p.l),
                            p.t,
                            Math.min(bx1, p.l + pW) - Math.max(bx0, p.l),
                            pH,
                        );
                        cx.strokeStyle = col + '66';
                        cx.lineWidth = 1;
                        cx.setLineDash([4, 4]);
                        if (b.lo > 0 && b.lo <= dm) {
                            cx.beginPath();
                            cx.moveTo(bx0, p.t);
                            cx.lineTo(bx0, p.t + pH);
                            cx.stroke();
                        }
                        if (b.hi < dm) {
                            cx.beginPath();
                            cx.moveTo(bx1, p.t);
                            cx.lineTo(bx1, p.t + pH);
                            cx.stroke();
                        }
                        cx.setLineDash([]);
                    });
                } else if (S.isoMode === 'single') {
                    const bx0 = p.l + (S.bLo / dm) * pW,
                        bx1 = p.l + (Math.min(S.bHi, dm) / dm) * pW;
                    cx.fillStyle = 'rgba(34,211,238,.06)';
                    cx.fillRect(
                        Math.max(bx0, p.l),
                        p.t,
                        Math.min(bx1, p.l + pW) - Math.max(bx0, p.l),
                        pH,
                    );
                    cx.strokeStyle = 'rgba(34,211,238,.3)';
                    cx.lineWidth = 1;
                    cx.setLineDash([4, 4]);
                    if (S.bLo > 0 && S.bLo <= dm) {
                        cx.beginPath();
                        cx.moveTo(bx0, p.t);
                        cx.lineTo(bx0, p.t + pH);
                        cx.stroke();
                    }
                    if (S.bHi < dm) {
                        cx.beginPath();
                        cx.moveTo(bx1, p.t);
                        cx.lineTo(bx1, p.t + pH);
                        cx.stroke();
                    }
                    cx.setLineDash([]);
                    // Butterworth gain curve overlay
                    cx.beginPath();
                    cx.strokeStyle = 'rgba(251,191,36,.4)';
                    cx.lineWidth = 1.5;
                    for (let px = 0; px < pW; px++) {
                        const freq = (px / pW) * dm;
                        let gain = 1;
                        if (S.bLo > 0)
                            gain *= butterworthGain(
                                freq,
                                S.bLo,
                                S.rolloff,
                                true,
                            );
                        if (S.bHi < S.sr / 2)
                            gain *= butterworthGain(
                                freq,
                                S.bHi,
                                S.rolloff,
                                false,
                            );
                        const y = p.t + pH - gain * pH;
                        px === 0
                            ? cx.moveTo(p.l + px, y)
                            : cx.lineTo(p.l + px, y);
                    }
                    cx.stroke();
                }
                // Grid
                cx.strokeStyle = 'rgba(255,255,255,.04)';
                cx.lineWidth = 0.5;
                for (let f = 0; f <= dm; f += dm > 4e3 ? 1e3 : 500) {
                    const x = p.l + (f / dm) * pW;
                    cx.beginPath();
                    cx.moveTo(x, p.t);
                    cx.lineTo(x, p.t + pH);
                    cx.stroke();
                }
                // FFT
                cx.beginPath();
                cx.strokeStyle = '#a78bfa';
                cx.lineWidth = 1;
                for (let i = 0; i < mag.length; i++) {
                    if (freqs[i] > dm) break;
                    const x = p.l + (freqs[i] / dm) * pW,
                        nm = Math.max(0, (mD[i] - mnD) / (mxD - mnD)),
                        y = p.t + pH - nm * pH;
                    i === 0 ? cx.moveTo(x, y) : cx.lineTo(x, y);
                }
                cx.stroke();
                // Axis
                cx.fillStyle = 'rgba(255,255,255,.3)';
                cx.font = '9px "DM Mono",monospace';
                cx.textAlign = 'center';
                for (let f = 0; f <= dm; f += dm > 4e3 ? 2e3 : 1e3)
                    cx.fillText(f + '', p.l + (f / dm) * pW, H - 6);
                cx.textAlign = 'right';
                cx.fillText(mxD.toFixed(0) + 'dB', p.l - 3, p.t + 10);
                // Band labels
                cx.font = '9px "DM Mono",monospace';
                cx.textAlign = 'center';
                if (S.isoMode === 'single') {
                    const bx0 = p.l + (S.bLo / dm) * pW,
                        bx1 = p.l + (Math.min(S.bHi, dm) / dm) * pW;
                    const bcx =
                        (Math.max(bx0, p.l) + Math.min(bx1, p.l + pW)) / 2;
                    cx.fillStyle = 'rgba(34,211,238,.5)';
                    cx.fillText(
                        `extracted: ${S.bLo}-${Math.min(S.bHi, Math.floor(dm))} Hz (order ${S.rolloff})`,
                        bcx,
                        p.t + 12,
                    );
                } else if (S.isoMode === 'multi' || S.isoMode === 'combined') {
                    cx.fillStyle = 'rgba(167,139,250,.5)';
                    cx.fillText(
                        `${S.bands.length} band${S.bands.length !== 1 ? 's' : ''} Â· ${S.isoMode}`,
                        p.l + pW / 2,
                        p.t + 12,
                    );
                } else if (S.isoMode === 'spectral') {
                    cx.fillStyle = 'rgba(251,191,36,.5)';
                    cx.fillText(
                        S.noiseProfile
                            ? `spectral subtraction (Î±=${S.overSub.toFixed(1)})`
                            : 'spectral sub â€” capture noise first',
                        p.l + pW / 2,
                        p.t + 12,
                    );
                }
            }

            let sIC = null,
                sCK = '';
            function dSTFT(pf) {
                $('anOff').style.display = 'none';
                const { cx, W, H } = gC('mC', 300);
                cx.fillStyle = '#0a0a0f';
                cx.fillRect(0, 0, W, H);
                if (!S.sig) return;
                const hp = Math.max(1, Math.floor(S.nfft * (1 - S.olP / 100))),
                    ck = `${S.sig.length}_${S.nfft}_${hp}_${S.wt}_${S.mf}_${S.dynR}_${S.zpR}_${W}_${H}`;
                const p = { l: 42, r: 8, t: 8, b: 26 },
                    pW = W - p.l - p.r,
                    pH = H - p.t - p.b,
                    dp = devicePixelRatio || 1;
                if (sCK !== ck) {
                    const { spec, numBins, numFrames, fftSize } = compSTFT(
                        S.sig,
                        S.nfft,
                        hp,
                        S.wt,
                        S.zpR,
                    );
                    S.stD = { spec, numBins, numFrames, fftSize, hop: hp };
                    const ny = S.sr / 2,
                        dm = Math.min(S.mf, ny),
                        mbi = Math.floor((dm / ny) * (numBins - 1));
                    let gM = -1e9;
                    const db = spec.map(f =>
                        f.map(v => {
                            const d = 20 * Math.log10(v + 1e-10);
                            if (d > gM) gM = d;
                            return d;
                        }),
                    );
                    const gm = gM - S.dynR;
                    const iW = Math.ceil(pW * dp),
                        iH = Math.ceil(pH * dp),
                        id = cx.createImageData(iW, iH);
                    for (let px = 0; px < iW; px++) {
                        const fi = Math.min(
                                Math.floor((px / iW) * numFrames),
                                numFrames - 1,
                            ),
                            fr = db[fi];
                        for (let py = 0; py < iH; py++) {
                            const bi = Math.min(
                                    Math.floor(((iH - py) / iH) * mbi),
                                    numBins - 1,
                                ),
                                v = (fr[bi] - gm) / S.dynR;
                            const [r, g, b] = mc(v);
                            const i = (py * iW + px) * 4;
                            id.data[i] = r;
                            id.data[i + 1] = g;
                            id.data[i + 2] = b;
                            id.data[i + 3] = 255;
                        }
                    }
                    sIC = id;
                    sCK = ck;
                }
                if (sIC) cx.putImageData(sIC, p.l * dp, p.t * dp);
                // Band overlay
                const ny = S.sr / 2,
                    dm = Math.min(S.mf, ny);
                function drawSTFTBand(lo, hi, color) {
                    const by0 = p.t + pH - (Math.min(hi, dm) / dm) * pH,
                        by1 = p.t + pH - (lo / dm) * pH;
                    cx.fillStyle = color + '1a';
                    cx.fillRect(
                        p.l,
                        Math.max(by0, p.t),
                        pW,
                        Math.min(by1, p.t + pH) - Math.max(by0, p.t),
                    );
                    cx.strokeStyle = color + '66';
                    cx.lineWidth = 1;
                    cx.setLineDash([4, 3]);
                    if (lo > 0) {
                        cx.beginPath();
                        cx.moveTo(p.l, by1);
                        cx.lineTo(p.l + pW, by1);
                        cx.stroke();
                    }
                    if (hi < dm) {
                        cx.beginPath();
                        cx.moveTo(p.l, by0);
                        cx.lineTo(p.l + pW, by0);
                        cx.stroke();
                    }
                    cx.setLineDash([]);
                }
                if (S.isoMode === 'multi' || S.isoMode === 'combined') {
                    S.bands.forEach((b, idx) =>
                        drawSTFTBand(b.lo, b.hi, HC[idx % HC.length]),
                    );
                } else if (S.isoMode === 'single') {
                    drawSTFTBand(S.bLo, S.bHi, '#22d3ee');
                }
                // Playhead
                if (pf >= 0) {
                    const x = p.l + pf * pW;
                    cx.strokeStyle = S.playing
                        ? S.playExt
                            ? '#22d3ee'
                            : '#34d399'
                        : 'rgba(167,139,250,.6)';
                    cx.lineWidth = S.playing ? 2 : 1.5;
                    cx.beginPath();
                    cx.moveTo(x, p.t);
                    cx.lineTo(x, p.t + pH);
                    cx.stroke();
                }
                // Axis
                cx.fillStyle = 'rgba(255,255,255,.3)';
                cx.font = '9px "DM Mono",monospace';
                cx.textAlign = 'right';
                for (let f = 0; f <= dm; f += dm > 4e3 ? 2e3 : 1e3) {
                    const y = p.t + pH - (f / dm) * pH;
                    cx.fillText(f + '', p.l - 3, y + 3);
                }
                cx.textAlign = 'center';
                const dur = S.sig.length / S.sr;
                for (
                    let s = 0;
                    s <= dur;
                    s += dur > 3 ? 1 : dur > 1 ? 0.5 : 0.2
                ) {
                    const x = p.l + (s / dur) * pW;
                    cx.fillText(s.toFixed(1) + 's', x, H - 4);
                }
            }

            function dLive(ct) {
                if (!S.sig || !S.anOn) return;
                const { cx, W, H } = gC('livC', 150);
                cx.fillStyle = '#0a0a0f';
                cx.fillRect(0, 0, W, H);
                const c = Math.floor((ct / S.dur) * S.sig.length),
                    st = Math.max(0, c - Math.floor(S.nfft / 2));
                const { mag, n } = fftSlice(S.sig, st, S.nfft, S.wt, S.zpR);
                const dm = Math.min(S.mf, S.sr / 2);
                let mxD = -1e9;
                const mD = [];
                for (let i = 0; i < mag.length; i++) {
                    const d = 20 * Math.log10(mag[i] + 1e-10);
                    if (d > mxD) mxD = d;
                    mD.push(d);
                }
                const mnD = mxD - S.dynR;
                const p = { l: 42, r: 8, t: 8, b: 22 },
                    pW = W - p.l - p.r,
                    pH = H - p.t - p.b;
                const nb = Math.floor((dm / (S.sr / 2)) * mag.length),
                    bW = Math.max(1, pW / nb);
                for (let i = 0; i < nb && i < mag.length; i++) {
                    const nm = Math.max(0, (mD[i] - mnD) / (mxD - mnD)),
                        x = p.l + (i / nb) * pW,
                        bH = nm * pH;
                    const freq = (i * S.sr) / n;
                    let inBand = false;
                    if (S.isoMode === 'single') {
                        inBand = freq >= S.bLo && freq <= S.bHi;
                    } else if (
                        S.isoMode === 'multi' ||
                        S.isoMode === 'combined'
                    ) {
                        inBand = S.bands.some(
                            b => freq >= b.lo && freq <= b.hi,
                        );
                    }
                    if (inBand) {
                        cx.fillStyle = `rgba(34,211,238,${0.4 + nm * 0.6})`;
                    } else {
                        const h = 260 - nm * 80;
                        cx.fillStyle = `hsla(${h},50%,${40 + nm * 15}%,${0.3 + nm * 0.3})`;
                    }
                    cx.fillRect(x, p.t + pH - bH, Math.max(bW - 0.5, 0.5), bH);
                }
            }

            function dOff() {
                const { cx, W, H } = gC('mC', S.tab === 'stft' ? 300 : 280);
                cx.fillStyle = '#0a0a0f';
                cx.fillRect(0, 0, W, H);
                $('anOff').style.display = '';
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FOURIER SERIES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function dFS() {
                $('anOff').style.display = 'none';
                if (!S.sig) return;
                const off = Math.floor(
                    (S.fsOff / 1000) * Math.max(0, S.sig.length - S.fsW),
                );
                const { harmonics, chunk } = compFS(S.sig, off, S.fsW);
                const numH = Math.min(S.fsH, harmonics.length - 1);
                // Main: tiled window
                const { cx, W, H } = gC('mC', 200);
                cx.fillStyle = '#0a0a0f';
                cx.fillRect(0, 0, W, H);
                const p = { l: 6, r: 6, t: 12, b: 18 },
                    pW = W - p.l - p.r,
                    pH = H - p.t - p.b;
                let mn = 1e9,
                    mx = -1e9;
                for (let i = 0; i < chunk.length; i++) {
                    if (chunk[i] < mn) mn = chunk[i];
                    if (chunk[i] > mx) mx = chunk[i];
                }
                const amp = Math.max(Math.abs(mn), Math.abs(mx), 0.001);
                for (let cp = -1; cp <= 1; cp++) {
                    const xO = p.l + ((cp + 1) / 3) * pW,
                        sW = pW / 3;
                    cx.strokeStyle =
                        cp === 0
                            ? 'rgba(255,255,255,.6)'
                            : 'rgba(255,255,255,.12)';
                    cx.lineWidth = cp === 0 ? 1.2 : 0.5;
                    if (cp === 0) {
                        cx.fillStyle = 'rgba(255,255,255,.02)';
                        cx.fillRect(xO, p.t, sW, pH);
                    }
                    cx.beginPath();
                    for (let i = 0; i < chunk.length; i++) {
                        const x = xO + (i / chunk.length) * sW,
                            y = p.t + pH / 2 - (chunk[i] / amp) * pH * 0.42;
                        i === 0 ? cx.moveTo(x, y) : cx.lineTo(x, y);
                    }
                    cx.stroke();
                }
                cx.fillStyle = 'rgba(251,191,36,.4)';
                cx.font = '10px "DM Mono",monospace';
                cx.textAlign = 'center';
                cx.fillText(
                    `fâ‚ = ${(S.sr / S.fsW).toFixed(1)} Hz Â· Period = ${((S.fsW / S.sr) * 1e3).toFixed(1)} ms`,
                    W / 2,
                    p.t - 1,
                );

                // Recon
                const recon = reconstructFS(harmonics, S.fsW, numH);
                const { cx: rx, W: rW, H: rH } = gC('fsRC', 90);
                rx.fillStyle = '#0a0a0f';
                rx.fillRect(0, 0, rW, rH);
                const rp = { l: 6, r: 6, t: 6, b: 6 },
                    rpW = rW - rp.l - rp.r,
                    rpH = rH - rp.t - rp.b;
                rx.strokeStyle = 'rgba(255,255,255,.25)';
                rx.lineWidth = 1;
                rx.beginPath();
                for (let i = 0; i < chunk.length; i++) {
                    const x = rp.l + (i / chunk.length) * rpW,
                        y = rp.t + rpH / 2 - (chunk[i] / amp) * rpH * 0.42;
                    i === 0 ? rx.moveTo(x, y) : rx.lineTo(x, y);
                }
                rx.stroke();
                rx.strokeStyle = '#34d399';
                rx.lineWidth = 1.5;
                rx.beginPath();
                for (let i = 0; i < recon.length; i++) {
                    const x = rp.l + (i / recon.length) * rpW,
                        y = rp.t + rpH / 2 - (recon[i] / amp) * rpH * 0.42;
                    i === 0 ? rx.moveTo(x, y) : rx.lineTo(x, y);
                }
                rx.stroke();
                rx.font = '9px "DM Mono",monospace';
                rx.textAlign = 'left';
                rx.fillStyle = 'rgba(255,255,255,.3)';
                rx.fillText('white=original', 5, 12);
                rx.fillStyle = 'rgba(52,211,153,.7)';
                rx.fillText('green=reconstruction', 110, 12);
                $('fsRCap').textContent =
                    `${numH} harmonics of ${Math.floor(S.fsW / 2)} possible`;

                // Harmonics
                const sc = $('fsScr');
                const need = numH + 1;
                while (sc.children.length > need) sc.removeChild(sc.lastChild);
                while (sc.children.length < need) {
                    const r = document.createElement('div');
                    r.className = 'fhr';
                    const l = document.createElement('div');
                    l.className = 'fhl';
                    const c = document.createElement('canvas');
                    c.className = 'fhc';
                    c.height = 32;
                    r.appendChild(l);
                    r.appendChild(c);
                    sc.appendChild(r);
                }
                for (let k = 0; k <= numH; k++) {
                    const h = harmonics[k],
                        row = sc.children[k],
                        lbl = row.children[0],
                        cvs = row.children[1];
                    const freq =
                        k === 0
                            ? 'DC'
                            : `${((k * S.sr) / S.fsW).toFixed(0)} Hz`;
                    const col = HC[k % HC.length];
                    lbl.innerHTML = `<strong>k=${k}</strong> ${freq}<br><span style="font-size:8px;color:${col}">amp ${h.amp.toFixed(3)}</span>`;
                    const dp = devicePixelRatio || 1,
                        cW = Math.max(
                            100,
                            cvs.parentElement.getBoundingClientRect().width -
                                110,
                        );
                    cvs.style.width = cW + 'px';
                    cvs.width = cW * dp;
                    cvs.height = 32 * dp;
                    const cc = cvs.getContext('2d');
                    cc.scale(dp, dp);
                    cc.fillStyle = 'rgba(0,0,0,.3)';
                    cc.fillRect(0, 0, cW, 32);
                    cc.strokeStyle = 'rgba(255,255,255,.04)';
                    cc.lineWidth = 0.5;
                    cc.beginPath();
                    cc.moveTo(0, 16);
                    cc.lineTo(cW, 16);
                    cc.stroke();
                    cc.strokeStyle = col;
                    cc.lineWidth = 1.2;
                    cc.beginPath();
                    for (let i = 0; i < S.fsW; i++) {
                        const t = i / S.fsW,
                            x = (i / S.fsW) * cW;
                        const v =
                            k === 0
                                ? h.amp * Math.cos(h.phase)
                                : h.amp *
                                  Math.cos(2 * Math.PI * k * t + h.phase);
                        const y = 16 - (v / amp) * 14;
                        i === 0 ? cc.moveTo(x, y) : cc.lineTo(x, y);
                    }
                    cc.stroke();
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PARAMS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function updP() {
                const g = $('pG'),
                    fs = S.sr,
                    ny = fs / 2;
                if (!S.sig) {
                    g.innerHTML = '';
                    return;
                }
                const hp = Math.max(1, Math.floor(S.nfft * (1 - S.olP / 100)));
                if (S.tab === 'fs') {
                    g.innerHTML =
                        pk('fs', fs.toLocaleString(), 'Hz', '', 'pfs') +
                        pk(
                            'Window',
                            S.fsW,
                            'samples',
                            ((S.fsW / fs) * 1e3).toFixed(1) + ' ms',
                            'fsW',
                        ) +
                        pk(
                            'fâ‚',
                            (fs / S.fsW).toFixed(1),
                            'Hz',
                            'fundamental',
                            'fsW',
                        ) +
                        pk(
                            'Harmonics',
                            S.fsH,
                            '',
                            'of ' + Math.floor(S.fsW / 2),
                            'fsH',
                        );
                } else if (S.tab === 'fft') {
                    let n = 1;
                    while (n < S.sig.length * S.zpR) n <<= 1;
                    g.innerHTML =
                        pk('fs', fs.toLocaleString(), 'Hz', '', 'pfs') +
                        pk('Nyquist', ny.toLocaleString(), 'Hz', '', 'pny') +
                        pk('N', S.sig.length.toLocaleString(), '', '', 'pN') +
                        pk('Î”f', (fs / n).toFixed(3), 'Hz', '', 'pdf') +
                        pk(
                            'Bins',
                            (n / 2 + 1).toLocaleString(),
                            '',
                            '',
                            'pbn',
                        ) +
                        pk(
                            'Band',
                            S.bLo + '-' + Math.min(S.bHi, Math.floor(ny)),
                            'Hz',
                            'extracted',
                            'bandSel',
                        );
                } else {
                    let fS = 1;
                    while (fS < S.nfft * S.zpR) fS <<= 1;
                    const nb = fS / 2 + 1,
                        nf = Math.max(
                            1,
                            Math.floor((S.sig.length - S.nfft) / hp) + 1,
                        );
                    g.innerHTML =
                        pk('fs', fs.toLocaleString(), 'Hz', '', 'pfs') +
                        pk(
                            'n_fft',
                            S.nfft,
                            '',
                            '' + ((S.nfft / fs) * 1e3).toFixed(1) + ' ms',
                            'nf',
                        ) +
                        pk('Hop', hp, '', '', 'ol') +
                        pk('Î”f', (fs / S.nfft).toFixed(1), 'Hz', '', 'pdf') +
                        pk(
                            'Î”t',
                            ((hp / fs) * 1e3).toFixed(1),
                            'ms',
                            '',
                            'pdt',
                        ) +
                        pk('Shape', nb + 'Ã—' + nf, '', '', 'psh') +
                        pk(
                            'Band',
                            S.bLo + '-' + Math.min(S.bHi, Math.floor(ny)),
                            'Hz',
                            '',
                            'bandSel',
                        );
                }
            }
            function pk(l, v, u, d, lk) {
                return `<div class="pc" onclick="L('${lk}')"><div class="pl">${l}</div><div class="pv">${v}<span class="pu">${u}</span></div><div class="pd">${d}</div></div>`;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LOADING
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function ldP(p) {
                stopA();
                S.preset = p;
                const fs = 44100,
                    d = 2;
                S.sr = fs;
                switch (p) {
                    case 'tones':
                        S.sig = gTones(fs, d);
                        S.lbl = '440+1k+2.5k Hz';
                        break;
                    case 'chirp':
                        S.sig = gChirp(fs, d);
                        S.lbl = 'Chirp';
                        break;
                    case 'impulses':
                        S.sig = gImp(fs, d);
                        S.lbl = 'Impulses';
                        break;
                    case 'chord':
                        S.sig = gChord(fs, d);
                        S.lbl = 'C Major';
                        break;
                    case 'square':
                        S.sig = gSq(fs, d);
                        S.lbl = 'Square 200Hz';
                        break;
                }
                S.dur = d;
                S.pOff = 0;
                S.aBuf = null;
                sCK = '';
                document
                    .querySelectorAll('#pBtns .bt')
                    .forEach(b => b.classList.toggle('ac', b.dataset.p === p));
                $('uz').style.display = '';
                $('finfo').style.display = 'none';
                $('mfS').max = fs / 2;
                $('bandHi').max = fs / 2;
                $('bandLo').max = fs / 2;
                if (S.bHi > fs / 2) {
                    S.bHi = fs / 2;
                    $('bandHi').value = S.bHi;
                    $('bandHiV').textContent = S.bHi + ' Hz';
                }
                updFSMax();
                recomputeExtraction();
                rAll();
            }

            function ldFile(file) {
                const rd = new FileReader();
                rd.onload = function (e) {
                    try {
                        stopA();
                        const ctx = ensCtx();
                        ctx.decodeAudioData(
                            e.target.result,
                            function (buf) {
                                let mono;
                                if (buf.numberOfChannels > 1) {
                                    mono = new Float64Array(buf.length);
                                    for (
                                        let c = 0;
                                        c < buf.numberOfChannels;
                                        c++
                                    ) {
                                        const d = buf.getChannelData(c);
                                        for (let i = 0; i < mono.length; i++)
                                            mono[i] += d[i];
                                    }
                                    for (let i = 0; i < mono.length; i++)
                                        mono[i] /= buf.numberOfChannels;
                                } else {
                                    const r = buf.getChannelData(0);
                                    mono = new Float64Array(r.length);
                                    for (let i = 0; i < r.length; i++)
                                        mono[i] = r[i];
                                }
                                const mx = buf.sampleRate * 30;
                                S.sig =
                                    mono.length > mx ? mono.slice(0, mx) : mono;
                                S.sr = buf.sampleRate;
                                S.lbl = file.name;
                                S.dur = S.sig.length / S.sr;
                                S.pOff = 0;
                                S.aBuf = null;
                                sCK = '';
                                $('uz').style.display = 'none';
                                $('finfo').style.display = 'flex';
                                $('fname').textContent = file.name;
                                $('fmeta').textContent =
                                    `${buf.sampleRate} Hz Â· ${buf.numberOfChannels}ch Â· ${(buf.length / buf.sampleRate).toFixed(2)}s`;
                                document
                                    .querySelectorAll('#pBtns .bt')
                                    .forEach(b => b.classList.remove('ac'));
                                const ny = buf.sampleRate / 2;
                                $('mfS').max = ny;
                                $('bandHi').max = ny;
                                $('bandLo').max = ny;
                                if (S.mf > ny) {
                                    S.mf = Math.min(8e3, ny);
                                    $('mfS').value = S.mf;
                                    $('mfV').textContent = S.mf + ' Hz';
                                }
                                if (S.bHi > ny) {
                                    S.bHi = ny;
                                    $('bandHi').value = S.bHi;
                                    $('bandHiV').textContent = S.bHi + ' Hz';
                                }
                                updFSMax();
                                recomputeExtraction();
                                rAll();
                            },
                            function (err) {
                                alert('Decode error: ' + err.message);
                            },
                        );
                    } catch (err) {
                        alert(err.message);
                    }
                };
                rd.readAsArrayBuffer(file);
            }

            function updFSMax() {
                if (S.sig) {
                    const mx = Math.min(S.sig.length, 8192);
                    $('fsWS').max = mx;
                    if (S.fsW > mx) {
                        S.fsW = mx;
                        $('fsWS').value = mx;
                        $('fsWV').textContent = mx;
                    }
                    $('fsHS').max = Math.floor(S.fsW / 2);
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // EVENTS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function init() {
                $('fin').addEventListener('change', e => {
                    if (e.target.files[0]) ldFile(e.target.files[0]);
                });
                const z = $('uz');
                z.addEventListener('dragover', e => {
                    e.preventDefault();
                    z.classList.add('dg');
                });
                z.addEventListener('dragleave', () => z.classList.remove('dg'));
                z.addEventListener('drop', e => {
                    e.preventDefault();
                    z.classList.remove('dg');
                    if (e.dataTransfer.files[0])
                        ldFile(e.dataTransfer.files[0]);
                });
                document.body.addEventListener('dragover', e =>
                    e.preventDefault(),
                );
                document.body.addEventListener('drop', e => {
                    e.preventDefault();
                    if (e.dataTransfer.files[0])
                        ldFile(e.dataTransfer.files[0]);
                });

                document.querySelectorAll('#pBtns .bt').forEach(b =>
                    b.addEventListener('click', () => {
                        ldP(b.dataset.p);
                        L('pre');
                    }),
                );

                document.querySelectorAll('.tab').forEach(t =>
                    t.addEventListener('click', () => {
                        S.tab = t.dataset.t;
                        document
                            .querySelectorAll('.tab')
                            .forEach(x => x.classList.toggle('ac', x === t));
                        const isFS = S.tab === 'fs';
                        $('fsCtrls').style.display = isFS ? 'none' : '';
                        $('fSerC').style.display = isFS ? '' : 'none';
                        $('fsViz').style.display = isFS ? '' : 'none';
                        $('stC').style.display = S.tab === 'stft' ? '' : 'none';
                        $('bandSec').style.display = isFS ? 'none' : '';
                        $('livS').style.display =
                            S.playing && S.anOn && !isFS ? '' : 'none';
                        sCK = '';
                        recomputeExtraction();
                        if (!S.playing) rAll();
                        else rFr();
                        updP();
                        L(t.dataset.l);
                    }),
                );

                document.querySelectorAll('#wBtns .bt').forEach(b =>
                    b.addEventListener('click', () => {
                        S.wt = b.dataset.w;
                        document
                            .querySelectorAll('#wBtns .bt')
                            .forEach(x => x.classList.toggle('ac', x === b));
                        sCK = '';
                        if (!S.playing) rAll();
                        L(b.dataset.l);
                    }),
                );
                document.querySelectorAll('#nfB .bt').forEach(b =>
                    b.addEventListener('click', () => {
                        S.nfft = parseInt(b.dataset.n);
                        document
                            .querySelectorAll('#nfB .bt')
                            .forEach(x => x.classList.toggle('ac', x === b));
                        sCK = '';
                        if (!S.playing) rAll();
                        updP();
                        L('nf');
                    }),
                );
                document.querySelectorAll('#zpB .bt').forEach(b =>
                    b.addEventListener('click', () => {
                        S.zpR = parseInt(b.dataset.z);
                        document
                            .querySelectorAll('#zpB .bt')
                            .forEach(x => x.classList.toggle('ac', x === b));
                        sCK = '';
                        if (!S.playing) rAll();
                        L('zp');
                    }),
                );

                $('mfS').addEventListener('input', e => {
                    S.mf = +e.target.value;
                    $('mfV').textContent = S.mf + ' Hz';
                    sCK = '';
                    if (!S.playing) rAll();
                });
                $('drS').addEventListener('input', e => {
                    S.dynR = +e.target.value;
                    $('drV').textContent = S.dynR + ' dB';
                    sCK = '';
                    if (!S.playing) rAll();
                });
                $('olS').addEventListener('input', e => {
                    S.olP = +e.target.value;
                    $('olV').textContent = S.olP + '%';
                    sCK = '';
                    if (!S.playing) rAll();
                    updP();
                });

                // Band sliders (single-band mode)
                $('bandLo').addEventListener('input', e => {
                    S.bLo = +e.target.value;
                    if (S.bLo > S.bHi) {
                        S.bHi = S.bLo;
                        $('bandHi').value = S.bHi;
                        $('bandHiV').textContent = S.bHi + ' Hz';
                    }
                    $('bandLoV').textContent = S.bLo + ' Hz';
                    recomputeExtraction();
                    if (!S.playing) rAll();
                    updP();
                });
                $('bandHi').addEventListener('input', e => {
                    S.bHi = +e.target.value;
                    if (S.bHi < S.bLo) {
                        S.bLo = S.bHi;
                        $('bandLo').value = S.bLo;
                        $('bandLoV').textContent = S.bLo + ' Hz';
                    }
                    $('bandHiV').textContent = S.bHi + ' Hz';
                    recomputeExtraction();
                    if (!S.playing) rAll();
                    updP();
                });

                // Rolloff slider
                $('rolloffS').addEventListener('input', e => {
                    S.rolloff = +e.target.value;
                    $('rolloffV').textContent = S.rolloff;
                    recomputeExtraction();
                    if (!S.playing) rAll();
                });

                // Wet/dry slider
                $('wetDry').addEventListener('input', e => {
                    S.wetDry = +e.target.value / 100;
                    S.prevWetDry = S.wetDry;
                    $('wetDryV').textContent = Math.round(S.wetDry * 100) + '%';
                });

                // Mode selector
                document
                    .querySelectorAll('#modeBtns .bt')
                    .forEach(b =>
                        b.addEventListener('click', () =>
                            switchMode(b.dataset.m),
                        ),
                    );

                // Order selector (combined mode)
                document.querySelectorAll('#orderBtns .bt').forEach(b =>
                    b.addEventListener('click', () => {
                        S.combOrder = b.dataset.o;
                        document
                            .querySelectorAll('#orderBtns .bt')
                            .forEach(x => x.classList.toggle('ac', x === b));
                        recomputeExtraction();
                        if (!S.playing) rAll();
                    }),
                );

                // Spectral subtraction sliders (standalone panel)
                function setupNoiseSliders(
                    startId,
                    endId,
                    startVId,
                    endVId,
                    overSubId,
                    overSubVId,
                    specFloorId,
                    specFloorVId,
                ) {
                    const startEl = $(startId),
                        endEl = $(endId);
                    if (startEl)
                        startEl.addEventListener('input', e => {
                            S.noiseStart = +e.target.value / 1000;
                            const dur = S.sig ? S.sig.length / S.sr : 1;
                            $(startVId).textContent =
                                (S.noiseStart * dur).toFixed(2) + 's';
                            // sync other panel
                            if (
                                startId === 'noiseStartS' &&
                                $('cNoiseStartS')
                            ) {
                                $('cNoiseStartS').value = e.target.value;
                                $('cNoiseStartV').textContent =
                                    $(startVId).textContent;
                            }
                            if (
                                startId === 'cNoiseStartS' &&
                                $('noiseStartS')
                            ) {
                                $('noiseStartS').value = e.target.value;
                                $('noiseStartV').textContent =
                                    $(startVId).textContent;
                            }
                            if (!S.playing) rAll();
                        });
                    if (endEl)
                        endEl.addEventListener('input', e => {
                            S.noiseEnd = +e.target.value / 1000;
                            const dur = S.sig ? S.sig.length / S.sr : 1;
                            $(endVId).textContent =
                                (S.noiseEnd * dur).toFixed(2) + 's';
                            if (endId === 'noiseEndS' && $('cNoiseEndS')) {
                                $('cNoiseEndS').value = e.target.value;
                                $('cNoiseEndV').textContent =
                                    $(endVId).textContent;
                            }
                            if (endId === 'cNoiseEndS' && $('noiseEndS')) {
                                $('noiseEndS').value = e.target.value;
                                $('noiseEndV').textContent =
                                    $(endVId).textContent;
                            }
                            if (!S.playing) rAll();
                        });
                    if ($(overSubId))
                        $(overSubId).addEventListener('input', e => {
                            S.overSub = +e.target.value / 100;
                            $(overSubVId).textContent = S.overSub.toFixed(1);
                            // sync
                            if (overSubId === 'overSubS' && $('cOverSubS')) {
                                $('cOverSubS').value = e.target.value;
                                $('cOverSubV').textContent =
                                    S.overSub.toFixed(1);
                            }
                            if (overSubId === 'cOverSubS' && $('overSubS')) {
                                $('overSubS').value = e.target.value;
                                $('overSubV').textContent =
                                    S.overSub.toFixed(1);
                            }
                            recomputeExtraction();
                            if (!S.playing) rAll();
                        });
                    if ($(specFloorId))
                        $(specFloorId).addEventListener('input', e => {
                            S.specFloor = +e.target.value / 1000;
                            $(specFloorVId).textContent =
                                S.specFloor.toFixed(3);
                            if (
                                specFloorId === 'specFloorS' &&
                                $('cSpecFloorS')
                            ) {
                                $('cSpecFloorS').value = e.target.value;
                                $('cSpecFloorV').textContent =
                                    S.specFloor.toFixed(3);
                            }
                            if (
                                specFloorId === 'cSpecFloorS' &&
                                $('specFloorS')
                            ) {
                                $('specFloorS').value = e.target.value;
                                $('specFloorV').textContent =
                                    S.specFloor.toFixed(3);
                            }
                            recomputeExtraction();
                            if (!S.playing) rAll();
                        });
                }
                setupNoiseSliders(
                    'noiseStartS',
                    'noiseEndS',
                    'noiseStartV',
                    'noiseEndV',
                    'overSubS',
                    'overSubV',
                    'specFloorS',
                    'specFloorV',
                );
                setupNoiseSliders(
                    'cNoiseStartS',
                    'cNoiseEndS',
                    'cNoiseStartV',
                    'cNoiseEndV',
                    'cOverSubS',
                    'cOverSubV',
                    'cSpecFloorS',
                    'cSpecFloorV',
                );

                // Spectrogram click-drag for band selection
                const mcEl = $('mC');
                let dragState = null;
                mcEl.addEventListener('mousedown', e => {
                    if (S.tab !== 'stft') return;
                    const rect = mcEl.getBoundingClientRect();
                    const stftP = { l: 42, r: 8, t: 8, b: 26 };
                    const stftPH = rect.height - stftP.t - stftP.b;
                    const y = e.clientY - rect.top;
                    const stftDm = Math.min(S.mf, S.sr / 2);
                    const freq = ((stftP.t + stftPH - y) / stftPH) * stftDm;
                    dragState = {
                        startFreq: Math.max(0, freq),
                        shiftKey: e.shiftKey,
                        startY: y,
                    };
                    $('mCov').classList.add('active');
                    $('mCW').classList.add('crosshair');
                });
                document.addEventListener('mousemove', e => {
                    if (!dragState) return;
                    const ov = $('mCov');
                    const rect = mcEl.getBoundingClientRect();
                    const dp = devicePixelRatio || 1;
                    ov.width = rect.width * dp;
                    ov.height = rect.height * dp;
                    ov.style.width = rect.width + 'px';
                    ov.style.height = rect.height + 'px';
                    const ctx = ov.getContext('2d');
                    ctx.scale(dp, dp);
                    ctx.clearRect(0, 0, rect.width, rect.height);
                    const stftP = { l: 42, r: 8, t: 8, b: 26 };
                    const stftPW = rect.width - stftP.l - stftP.r;
                    const stftPH = rect.height - stftP.t - stftP.b;
                    const y = e.clientY - rect.top;
                    const y0 = Math.min(dragState.startY, y),
                        y1 = Math.max(dragState.startY, y);
                    ctx.fillStyle = 'rgba(34,211,238,.15)';
                    ctx.fillRect(
                        stftP.l,
                        Math.max(y0, stftP.t),
                        stftPW,
                        Math.min(y1, stftP.t + stftPH) - Math.max(y0, stftP.t),
                    );
                    ctx.strokeStyle = 'rgba(34,211,238,.6)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(
                        stftP.l,
                        Math.max(y0, stftP.t),
                        stftPW,
                        Math.min(y1, stftP.t + stftPH) - Math.max(y0, stftP.t),
                    );
                });
                document.addEventListener('mouseup', e => {
                    if (!dragState) return;
                    $('mCov').classList.remove('active');
                    $('mCW').classList.remove('crosshair');
                    const ov = $('mCov');
                    const ctx = ov.getContext('2d');
                    ctx.clearRect(0, 0, ov.width, ov.height);
                    const rect = mcEl.getBoundingClientRect();
                    const stftP = { l: 42, r: 8, t: 8, b: 26 };
                    const stftPH = rect.height - stftP.t - stftP.b;
                    const y = e.clientY - rect.top;
                    const stftDm = Math.min(S.mf, S.sr / 2);
                    const endFreq = Math.max(
                        0,
                        ((stftP.t + stftPH - y) / stftPH) * stftDm,
                    );
                    const lo = Math.max(
                        0,
                        Math.min(dragState.startFreq, endFreq),
                    );
                    const hi = Math.min(
                        stftDm,
                        Math.max(dragState.startFreq, endFreq),
                    );
                    if (Math.abs(hi - lo) < 20) {
                        dragState = null;
                        return;
                    }
                    if (S.isoMode === 'single') {
                        S.bLo = Math.round(lo);
                        S.bHi = Math.round(hi);
                        $('bandLo').value = S.bLo;
                        $('bandLoV').textContent = S.bLo + ' Hz';
                        $('bandHi').value = S.bHi;
                        $('bandHiV').textContent = S.bHi + ' Hz';
                    } else if (
                        S.isoMode === 'multi' ||
                        S.isoMode === 'combined'
                    ) {
                        if (dragState.shiftKey) {
                            addBand(lo, hi);
                        } else {
                            S.bands = [
                                {
                                    lo: Math.round(lo),
                                    hi: Math.round(hi),
                                    rolloff: 4,
                                },
                            ];
                            renderBands();
                        }
                    }
                    dragState = null;
                    recomputeExtraction();
                    if (!S.playing) rAll();
                    updP();
                });

                // Waveform region selection (drag to select)
                const wCEl = $('wC');
                let wDrag = null;
                $('wCW').addEventListener('mousedown', e => {
                    if (e.target.tagName === 'INPUT') return;
                    const rect = wCEl.getBoundingClientRect();
                    const frac = Math.max(
                        0,
                        Math.min(1, (e.clientX - rect.left) / rect.width),
                    );
                    wDrag = { startFrac: frac };
                    e.preventDefault();
                });
                document.addEventListener('mousemove', e => {
                    if (!wDrag) return;
                    const rect = wCEl.getBoundingClientRect();
                    const frac = Math.max(
                        0,
                        Math.min(1, (e.clientX - rect.left) / rect.width),
                    );
                    const lo = Math.min(wDrag.startFrac, frac);
                    const hi = Math.max(wDrag.startFrac, frac);
                    if (hi - lo > 0.005) {
                        S.selStart = lo;
                        S.selEnd = hi;
                        S.hasSelection = true;
                        if (!S.playing) rAll();
                    }
                });
                document.addEventListener('mouseup', e => {
                    if (!wDrag) return;
                    const rect = wCEl.getBoundingClientRect();
                    const frac = Math.max(
                        0,
                        Math.min(1, (e.clientX - rect.left) / rect.width),
                    );
                    const lo = Math.min(wDrag.startFrac, frac);
                    const hi = Math.max(wDrag.startFrac, frac);
                    if (hi - lo > 0.005) {
                        S.selStart = lo;
                        S.selEnd = hi;
                        S.hasSelection = true;
                    } else {
                        // Click without drag = seek to position
                        seekTo(frac);
                    }
                    wDrag = null;
                    if (!S.playing) rAll();
                });
                // Double-click waveform to clear selection
                $('wCW').addEventListener('dblclick', e => {
                    if (e.target.tagName === 'INPUT') return;
                    S.hasSelection = false;
                    S.selStart = 0;
                    S.selEnd = 1;
                    if (!S.playing) rAll();
                    L('wf');
                });

                // Editable number values
                makeEditable($('bandLoV'), {
                    min: 0,
                    max: S.sr / 2,
                    step: 10,
                    suffix: ' Hz',
                    onChange: v => {
                        S.bLo = v;
                        $('bandLo').value = v;
                        if (S.bLo > S.bHi) {
                            S.bHi = S.bLo;
                            $('bandHi').value = S.bHi;
                            $('bandHiV').textContent = S.bHi + ' Hz';
                        }
                        recomputeExtraction();
                        if (!S.playing) rAll();
                        updP();
                    },
                });
                makeEditable($('bandHiV'), {
                    min: 0,
                    max: S.sr / 2,
                    step: 10,
                    suffix: ' Hz',
                    onChange: v => {
                        S.bHi = v;
                        $('bandHi').value = v;
                        if (S.bHi < S.bLo) {
                            S.bLo = S.bHi;
                            $('bandLo').value = S.bLo;
                            $('bandLoV').textContent = S.bLo + ' Hz';
                        }
                        recomputeExtraction();
                        if (!S.playing) rAll();
                        updP();
                    },
                });
                makeEditable($('rolloffV'), {
                    min: 1,
                    max: 12,
                    step: 1,
                    suffix: '',
                    onChange: v => {
                        S.rolloff = v;
                        $('rolloffS').value = v;
                        recomputeExtraction();
                        if (!S.playing) rAll();
                    },
                });
                makeEditable($('mfV'), {
                    min: 500,
                    max: 22050,
                    step: 250,
                    suffix: ' Hz',
                    onChange: v => {
                        S.mf = v;
                        $('mfS').value = v;
                        sCK = '';
                        if (!S.playing) rAll();
                    },
                });
                makeEditable($('drV'), {
                    min: 20,
                    max: 120,
                    step: 5,
                    suffix: ' dB',
                    onChange: v => {
                        S.dynR = v;
                        $('drS').value = v;
                        sCK = '';
                        if (!S.playing) rAll();
                    },
                });
                makeEditable($('olV'), {
                    min: 0,
                    max: 90,
                    step: 5,
                    suffix: '%',
                    onChange: v => {
                        S.olP = v;
                        $('olS').value = v;
                        sCK = '';
                        if (!S.playing) rAll();
                        updP();
                    },
                });
                makeEditable($('fsWV'), {
                    min: 64,
                    max: 8192,
                    step: 64,
                    suffix: '',
                    onChange: v => {
                        S.fsW = v;
                        $('fsWS').value = v;
                        $('fsHS').max = Math.floor(v / 2);
                        if (S.fsH > Math.floor(v / 2)) {
                            S.fsH = Math.floor(v / 2);
                            $('fsHS').value = S.fsH;
                            $('fsHV').textContent = S.fsH;
                        }
                        recomputeExtraction();
                        if (!S.playing) rAll();
                        updP();
                    },
                });
                makeEditable($('fsHV'), {
                    min: 1,
                    max: 64,
                    step: 1,
                    suffix: '',
                    onChange: v => {
                        S.fsH = v;
                        $('fsHS').value = v;
                        recomputeExtraction();
                        if (!S.playing) rAll();
                        updP();
                    },
                });
                makeEditable($('wetDryV'), {
                    min: 0,
                    max: 100,
                    step: 1,
                    suffix: '%',
                    onChange: v => {
                        S.wetDry = v / 100;
                        S.prevWetDry = S.wetDry;
                        $('wetDry').value = v;
                    },
                });
                makeEditable($('overSubV'), {
                    min: 0.5,
                    max: 4.0,
                    step: 0.1,
                    suffix: '',
                    onChange: v => {
                        S.overSub = v;
                        $('overSubS').value = Math.round(v * 100);
                        if ($('cOverSubS')) {
                            $('cOverSubS').value = Math.round(v * 100);
                            $('cOverSubV').textContent = v.toFixed(1);
                        }
                        recomputeExtraction();
                        if (!S.playing) rAll();
                    },
                });
                makeEditable($('specFloorV'), {
                    min: 0.001,
                    max: 0.1,
                    step: 0.001,
                    suffix: '',
                    fmt: v => v.toFixed(3),
                    onChange: v => {
                        S.specFloor = v;
                        $('specFloorS').value = Math.round(v * 1000);
                        if ($('cSpecFloorS')) {
                            $('cSpecFloorS').value = Math.round(v * 1000);
                            $('cSpecFloorV').textContent = v.toFixed(3);
                        }
                        recomputeExtraction();
                        if (!S.playing) rAll();
                    },
                });

                // FS sliders
                $('fsWS').addEventListener('input', e => {
                    S.fsW = +e.target.value;
                    $('fsWV').textContent = S.fsW;
                    $('fsHS').max = Math.floor(S.fsW / 2);
                    if (S.fsH > Math.floor(S.fsW / 2)) {
                        S.fsH = Math.floor(S.fsW / 2);
                        $('fsHS').value = S.fsH;
                        $('fsHV').textContent = S.fsH;
                    }
                    recomputeExtraction();
                    if (!S.playing) rAll();
                    updP();
                });
                $('fsHS').addEventListener('input', e => {
                    S.fsH = +e.target.value;
                    $('fsHV').textContent = S.fsH;
                    recomputeExtraction();
                    if (!S.playing) rAll();
                    updP();
                });
                $('fsOS').addEventListener('input', e => {
                    S.fsOff = +e.target.value;
                    $('fsOV').textContent = Math.floor(
                        (S.fsOff / 1000) *
                            Math.max(0, S.sig ? S.sig.length - S.fsW : 0),
                    );
                    recomputeExtraction();
                    if (!S.playing) rAll();
                });

                const sk = $('seek');
                let sking = false;
                sk.addEventListener('mousedown', () => {
                    sking = true;
                });
                sk.addEventListener('input', () => {
                    if (sking) seekTo(+sk.value / 1e3);
                });
                sk.addEventListener('mouseup', () => {
                    sking = false;
                });
                sk.addEventListener('change', () => {
                    seekTo(+sk.value / 1e3);
                    sking = false;
                });

                document.addEventListener('keydown', e => {
                    if (
                        e.target.tagName === 'INPUT' ||
                        e.target.classList.contains('inline-edit')
                    )
                        return;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        togPlay();
                    }
                    if (e.code === 'Escape') stopA();
                    if (e.code === 'KeyA') togAn();
                    if (e.code === 'KeyE') togExtPlay();
                });
                window.addEventListener('resize', () => {
                    sCK = '';
                    if (!S.playing) rAll();
                });
            }

            // Populate educational panels
            if ($('eduSingle')) $('eduSingle').innerHTML = EDU.single;
            if ($('eduMulti')) $('eduMulti').innerHTML = EDU.multi;
            if ($('eduSpectral')) $('eduSpectral').innerHTML = EDU.spectral;
            if ($('eduCombined')) $('eduCombined').innerHTML = EDU.combined;

            ldP('tones');
            init();
            renderBands();
        </script>
    </body>
</html>
